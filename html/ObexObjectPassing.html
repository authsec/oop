<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "https://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>

<HEAD>


<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.08+10 of 2006-02-03">
<LINK rel="stylesheet" type="text/css" href="ObexObjectPassing.css">
</HEAD>

<BODY >
<!--HEVEA command line is: hevea -s ccg.hva dajf.tex -o ObexObjectPassing.html -->
<!--HTMLHEAD-->
<DIV CLASS="flushright"><A HREF="https://oop.coffeecrew.org"><FONT SIZE=2>OBEX Object Passing Home</FONT></A><FONT SIZE=2> </FONT><A HREF="../dox/ObexObjectPassing.pdf"><FONT SIZE=2>(PDF)</FONT></A></DIV><!--ENDHTML-->
<!--PREFIX <ARG ></ARG>-->
<!--CUT DEF chapter 1 -->


<BR>
<BR>

<BR>
<BR>
<DIV CLASS="flushright">
<HR SIZE=2>
<BR>

 <FONT SIZE=7><SPAN STYLE="font-variant:small-caps">OBEX Object Passing<BR>
�ber Bluetooth</SPAN></FONT><BR>
<BR>
<HR SIZE=2><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>

<A HREF="https://www.hs-furtwangen.de"><SPAN STYLE="font-variant:small-caps"><FONT SIZE=4>Hochschule Furtwangen</FONT></SPAN></A><SPAN STYLE="font-variant:small-caps"><FONT SIZE=4>
 &sdot; 31. M�rz 2006</FONT></SPAN><SPAN STYLE="font-variant:small-caps"><BR>
<BR>

Wintersemester 2005/2006<BR>

Jens Frey &sdot; </SPAN><A HREF="mailto:jens.frey@coffeecrew.org"><SPAN STYLE="font-variant:small-caps">jens.frey@coffeecrew.org</SPAN></A><SPAN STYLE="font-variant:small-caps"><BR>
</SPAN><SPAN STYLE="font-variant:small-caps">
Matrikelnummer &sdot; 216401<BR>
</SPAN><A HREF="https://www.fh-furtwangen.de/fachbereiche/in/deutsch/index.html"><SPAN STYLE="font-variant:small-caps">Fakult�t &sdot; Informatik</SPAN></A><SPAN STYLE="font-variant:small-caps"><BR>
</SPAN><SPAN STYLE="font-variant:small-caps">
Studiengang &sdot; Computer Networking<BR>
 
<BR>
<BR>

<FONT SIZE=6>Diplomarbeit<BR>
</FONT>
<BR>
<BR>

Referent &sdot; Prof. Dr. Harald Gl�ser<BR>
Koreferent &sdot; Prof. Dr. Wolfgang Bauer<BR>

</SPAN></DIV>

<BR>
<BR>


<BR>
<BR>
<FONT SIZE=5>Eidesstattliche Erkl�rung</FONT><BR>
Ich erkl�re hiermit an Eides statt, dass ich die vorliegende Diplomarbeit selbstst�ndig
und ohne unzul�ssige fremde Hilfe angefertigt habe. Die verwendeten Quellen und
Hilfsmittel sind vollst�ndig zitiert.
<DIV CLASS="flushright">
Furtwangen, 31. M�rz 2006<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>

Jens Frey<BR>
<BR>

</DIV>

<BR>
<BR>

<!--TOC chapter Abstrakt-->

<H1 CLASS="chapter">Abstrakt</H1><!--SEC END -->


Die vorliegende Arbeit beschreibt das Design sowie die Implementierung
des OBEX Object Passing (OOP) Mechanismus, welcher dazu entwickelt
wurde um Java Objekte �ber eine Bluetooth Funkstrecke von einem
Bluetooth und Java f�higen Endger�t auf ein zweites zu �bertragen.<BR>


<FONT SIZE=2>Die Informationen der vorliegenden Arbeit werden ohne R�cksicht auf
einen eventuellen Patentschutz publiziert. Die wiedergegebenen
Gebrauchsnamen, Handelsnamen, Warenbezeichnungen usw. k�nnen auch ohne
besondere Kennzeichnung Marken sein und unterliegen als solche den
gesetzlichen Bestimmungen.
</FONT>
<BR>
<BR>


 




<!--TOC chapter Inhaltsverzeichnis-->

<H1 CLASS="chapter">Inhaltsverzeichnis</H1><!--SEC END -->

<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc1">Kapitel&nbsp;1&nbsp;&nbsp;Einleitung</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc2">1.1&nbsp;&nbsp;Aufbau der Arbeit</A>
<LI CLASS="li-toc"><A HREF="#htoc3">1.2&nbsp;&nbsp;Zielsetzung der Arbeit</A>
<LI CLASS="li-toc"><A HREF="#htoc4">1.3&nbsp;&nbsp;Anwendungsszenarien</A>
<LI CLASS="li-toc"><A HREF="#htoc5">1.4&nbsp;&nbsp;Technische Randbedingungen</A>
<LI CLASS="li-toc"><A HREF="#htoc6">1.5&nbsp;&nbsp;Bezugsquellen</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc7">Kapitel&nbsp;2&nbsp;&nbsp;Technische Grundlagen</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc8">2.1&nbsp;&nbsp;Bluetooth</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc9">2.1.1&nbsp;&nbsp;Physical Layer</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc10">2.1.1.1&nbsp;&nbsp;Physical Channel</A>
<LI CLASS="li-toc"><A HREF="#htoc11">2.1.1.2&nbsp;&nbsp;Physical Links</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc12">2.1.2&nbsp;&nbsp;Logical Layer</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc13">2.1.2.1&nbsp;&nbsp;Logical Transports</A>
<LI CLASS="li-toc"><A HREF="#htoc14">2.1.2.2&nbsp;&nbsp;Logical Links</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc15">2.1.3&nbsp;&nbsp;L2CAP Layer</A>
<LI CLASS="li-toc"><A HREF="#htoc16">2.1.4&nbsp;&nbsp;Bluetooth Sicherheit</A>
<LI CLASS="li-toc"><A HREF="#htoc17">2.1.5&nbsp;&nbsp;Generic Access Profile (GAP)</A>
<LI CLASS="li-toc"><A HREF="#htoc18">2.1.6&nbsp;&nbsp;Bluetooth Implementierungen</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc19">2.2&nbsp;&nbsp;Java 2 Micro Edition (J2ME)</A>
<LI CLASS="li-toc"><A HREF="#htoc20">2.3&nbsp;&nbsp;Connected Limited Device Configuration (CLDC)</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc21">2.3.1&nbsp;&nbsp;Generic Connection Framework (GCF)</A>
<LI CLASS="li-toc"><A HREF="#htoc22">2.3.2&nbsp;&nbsp;CLDC Sicherheit</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc23">2.4&nbsp;&nbsp;Mobile Information Device Profile (MIDP)</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc24">2.4.1&nbsp;&nbsp;Record Management System (RMS)</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc25">2.4.1.1&nbsp;&nbsp;Record Store</A>
<LI CLASS="li-toc"><A HREF="#htoc26">2.4.1.2&nbsp;&nbsp;Records</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc27">2.4.2&nbsp;&nbsp;MIDP Sicherheit</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc28">2.5&nbsp;&nbsp;Java API for Bluetooth (JSR-82)</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc29">2.5.1&nbsp;&nbsp;Anforderungen</A>
<LI CLASS="li-toc"><A HREF="#htoc30">2.5.2&nbsp;&nbsp;Paketierung</A>
<LI CLASS="li-toc"><A HREF="#htoc31">2.5.3&nbsp;&nbsp;Bluetooth Control Center</A>
<LI CLASS="li-toc"><A HREF="#htoc32">2.5.4&nbsp;&nbsp;Eigenschaften des Ger�ts</A>
<LI CLASS="li-toc"><A HREF="#htoc33">2.5.5&nbsp;&nbsp;Client-/Server Modell</A>
<LI CLASS="li-toc"><A HREF="#htoc34">2.5.6&nbsp;&nbsp;Discovery</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc35">2.5.6.1&nbsp;&nbsp;Device Discovery</A>
<LI CLASS="li-toc"><A HREF="#htoc36">2.5.6.2&nbsp;&nbsp;Service Discovery</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc37">2.5.7&nbsp;&nbsp;Generic Access Profile (GAP)</A>
<LI CLASS="li-toc"><A HREF="#htoc38">2.5.8&nbsp;&nbsp;Kommunikation</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc39">2.5.8.1&nbsp;&nbsp;Serial Port Profile</A>
<LI CLASS="li-toc"><A HREF="#htoc40">2.5.8.2&nbsp;&nbsp;Object Exchange Protocol (OBEX)</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc41">2.5.9&nbsp;&nbsp;JSR-82 Sicherheit</A>
</UL>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc42">Kapitel&nbsp;3&nbsp;&nbsp;OBEX Object Passing</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc43">3.1&nbsp;&nbsp;Technische Voraussetzungen</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc44">3.1.1&nbsp;&nbsp;Bluetooth-Stack</A>
<LI CLASS="li-toc"><A HREF="#htoc45">3.1.2&nbsp;&nbsp;JSR-82 Implementierung</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc46">3.2&nbsp;&nbsp;Design</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc47">3.2.1&nbsp;&nbsp;Paket &gt;&gt;oop&lt;&lt;</A>
<LI CLASS="li-toc"><A HREF="#htoc48">3.2.2&nbsp;&nbsp;Paket &gt;&gt;impl&lt;&lt;</A>
<LI CLASS="li-toc"><A HREF="#htoc49">3.2.3&nbsp;&nbsp;Paket &gt;&gt;util&lt;&lt;</A>
<LI CLASS="li-toc"><A HREF="#htoc50">3.2.4&nbsp;&nbsp;Paket &gt;&gt;exceptions&lt;&lt;</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc51">3.3&nbsp;&nbsp;Deus ex machina</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc52">3.3.1&nbsp;&nbsp;ObjectReceiver</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc53">3.4&nbsp;&nbsp;Tests</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc54">Kapitel&nbsp;4&nbsp;&nbsp;Entwickeln mit OOP</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc55">4.1&nbsp;&nbsp;Grundlagen der J2ME Programmierung</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc56">4.1.1&nbsp;&nbsp;Lebenszyklus eines MIDlets</A>
<LI CLASS="li-toc"><A HREF="#htoc57">4.1.2&nbsp;&nbsp;User-Interface Entwicklung</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc58">4.2&nbsp;&nbsp;Projektorganisation</A>
<LI CLASS="li-toc"><A HREF="#htoc59">4.3&nbsp;&nbsp;Beispielapplikation</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc60">Kapitel&nbsp;5&nbsp;&nbsp;Konklusion und Ausblick</A>
<LI CLASS="li-toc"><A HREF="#htoc61">Anhang&nbsp;A&nbsp;&nbsp;Entwicklungsumgebung</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc62">A.1&nbsp;&nbsp;Anlegen eines J2ME Projekts mit OOP</A>
<LI CLASS="li-toc"><A HREF="#htoc63">A.2&nbsp;&nbsp;Beispielapplikation in Betrieb nehmen</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc64">Anhang&nbsp;B&nbsp;&nbsp;Glossar und Abk�rzungsverzeichnis</A>
<LI CLASS="li-toc">Listings
</UL>








<BR>
<BR>
<!--TOC chapter Einleitung-->

<H1 CLASS="chapter"><A NAME="htoc1">Kapitel&nbsp;1</A>&nbsp;&nbsp;Einleitung</H1><!--SEC END -->

<A NAME="el"></A>
Die Bluetooth Technologie erfreut sich in letzter Zeit immer gr�sserer
Beliebtheit, wird doch durch sie das l�stige Kabel endlich obsolet. Im
Bereich der Applikationsentwicklung fehlt dem Programmierer jedoch die
M�glichkeit Java Objekte zwischen zwei Endger�ten auszutauschen. Diese
L�cke wird durch die vorliegende Arbeit geschlossen.<BR>
<BR>
<!--TOC section Aufbau der Arbeit-->

<H2 CLASS="section"><A NAME="htoc2">1.1</A>&nbsp;&nbsp;Aufbau der Arbeit</H2><!--SEC END -->

<A NAME="el:aufb"></A>
Die Arbeit ist wie folgt aufgeteilt:
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description">
<B>Kapitel 1</B><DD CLASS="dd-description"> beschreibt die Zielsetzung, technische
 Randbedingungen, sowie denkbare Anwendungsszenarien, und
 Bezugsquellen der vorliegenden Arbeit.
<DT CLASS="dt-description"><B>Kapitel 2</B><DD CLASS="dd-description"> gibt einen kurzen �berblick �ber die zur Realisierung
 der Bibliothek eingesetzten Technologien.
<DT CLASS="dt-description"><B>Kapitel 3</B><DD CLASS="dd-description"> beschreibt das Design der entwickelten Bibliothek,
 sowie deren Funktionsweise.
<DT CLASS="dt-description"><B>Kapitel 4</B><DD CLASS="dd-description"> beschreibt den konkreten Einsatz der Bibliothek
 anhand eines einfachen Beispiels, und vermittelt die Grundlagen der
 J2ME Applikationsentwicklung.
<DT CLASS="dt-description"><B>Kapitel 5</B><DD CLASS="dd-description"> fasst die Arbeit zusammen und gibt einen Ausblick auf
 Weiterentwicklungsm�glichkeiten der Bibliothek.
<DT CLASS="dt-description"><B>Anhang A</B><DD CLASS="dd-description"> demonstriert, wie innerhalb der eingesetzten Netbeans
 IDE ein J2ME Projekt erstellt werden kann, das die entwickelte
 Bibliothek einsetzt. Ferner wird beschrieben wie die
 Beispielapplikation in Betrieb genommen werden kann.
</DL>
<!--TOC section Zielsetzung der Arbeit-->

<H2 CLASS="section"><A NAME="htoc3">1.2</A>&nbsp;&nbsp;Zielsetzung der Arbeit</H2><!--SEC END -->

<A NAME="el:ziel"></A>
<A NAME="@default0"></A>
Ziel der Arbeit ist es eine Bibliothek zu erstellen, mit deren Hilfe
sich Java Objekte �ber ein Bluetooth Funknetzwerk �bertragen lassen.
Ein solcher Mechanismus findet Anwendung, wenn man gezwungen ist,
Objekte �ber ein Netzwerk transportieren zu m�ssen, wie es in
gr�sseren Implementierungen der Fall ist. Dies ist bspw. dann
notwendig, wenn Daten aus einer Datenbank an ein bestimmes Endger�t
oder einen Serverprozess auf einer physisch differenten Maschine zu
senden sind.<BR>
<BR>
Die Anwendungsentwicklung &ndash; im Bereich der Daten�bertragung &ndash; wird
mit der entwickelten Bibliothek merklich vereinfacht. Der
Programmierer wird lediglich angehalten, in seinen Entit�tsobjekten
eine vorgegebene Schnittstelle zu implementieren. Sofern die
Schnittstelle implementiert wurde, ist die Bibliothek in der Lage, das
gegebene Objekt selbstst�ndig zu �bertragen.<BR>
<BR>
Diese Arbeit bildet <I><FONT COLOR=maroon>keinen</FONT></I> Serialisierungsmechanismus nach,
auch wenn es auf Grund der Schnittstellendefinition danach
aussehen mag. Die Implementierung der Serialisierung muss vom
Programmierer selbst durchgef�hrt werden.<BR>
<BR>
<!--TOC section Anwendungsszenarien-->

<H2 CLASS="section"><A NAME="htoc4">1.3</A>&nbsp;&nbsp;Anwendungsszenarien</H2><!--SEC END -->

<A NAME="el:awz"></A>
<A NAME="@default1"></A>
Die Anwendungsszenarien der Bibliothek sind vielf�ltig. Sie kann
prinzipiell bei jeder Art von Objektdaten�bertragung eingesetzt
werden.<BR>
<BR>
Eine konkrete Anwendung w�re bspw. eine Applikation, die mit einem
K�hlschrank interagiert. Die Software des K�hlschranks verwaltet einen
&#8222;Einkaufszettel&#8220; mit Hilfe von Produktobjekten. Diese Objekte k�nnen
mit Hilfe der Bibliothek leicht auf ein mobiles Endger�t �bertragen
werden, das im Gesch�ft als &#8222;Einkaufszettel&#8220; dient.<BR>
<BR>
Eine andere Anwendungsm�glichkeit w�re z.&nbsp;B. die �bertragung von
Punktobjekten, die von einer Landkartenapplikation ausgewertet
werden. <BR>
<BR>
<!--TOC section Technische Randbedingungen-->

<H2 CLASS="section"><A NAME="htoc5">1.4</A>&nbsp;&nbsp;Technische Randbedingungen</H2><!--SEC END -->

<A NAME="el:tr"></A>
<A NAME="@default2"></A> Der Einsatz von Bluetooth sowie der <I><FONT COLOR=maroon>Java
 2 Platform, Micro Edition</FONT></I> waren technische Randbedingungen der
Arbeit. Um eine maximale Transparenz und Kosteneffizienz zu erreichen,
sind, zur Realisierung des Projekts, bestehende Technologien aus dem
Open Source Bereich eingesetzt worden.<BR>
<BR>
<!--TOC section Bezugsquellen-->

<H2 CLASS="section"><A NAME="htoc6">1.5</A>&nbsp;&nbsp;Bezugsquellen</H2><!--SEC END -->

<A NAME="el:bq"></A>
Die vorliegende Arbeit, sowie deren zugeh�riger Quellcode kann unter
der URL <A HREF="https://oop.coffeecrew.org/"><TT>https://oop.coffeecrew.org/</TT></A> bezogen werden. <BR>
<BR>
An dieser Stelle soll speziell auf die verf�gbare JavaDoc hingewiesen
werden, die direkt unter der URL <A HREF="https://oop.coffeecrew.org/doc/"><TT>https://oop.coffeecrew.org/doc/</TT></A>
erreicht werden kann. Sie ist zus�tzlich mit Beispielen versehen
worden, um die Einarbeitungszeit des Entwicklers zu verk�rzen.<BR>
<BR>
S�mtliche Beispielprogramme sind unter der angegebenen Adresse
verf�gbar. Die Webseite ist zus�tzlich auf der beigelegten CD-ROM
offline verf�gbar gemacht.<BR>
<BR>

<!--TOC chapter Technische Grundlagen-->

<H1 CLASS="chapter"><A NAME="htoc7">Kapitel&nbsp;2</A>&nbsp;&nbsp;Technische Grundlagen</H1><!--SEC END -->

<A NAME="tgl"></A>
<A NAME="@default3"></A>
<A NAME="@default4"></A>
In diesem Kapitel werden die zur Umsetzung, bzw. zum Verst�ndnis der
vorliegenden Arbeit, notwendigen Technologien bzw. Spezifikationen
kurz angesprochen. Ist der Leser mit den folgenden Technologien
bereits vertraut, kann dieses Kapitel problemlos �bersprungen werden.
Die Technologien werden nicht in vollem Umfang diskutiert, lediglich
der jeweils relevante Teil wird herausgegriffen und kurz
zusammengefasst bzw. gegeneinander abgegrenzt. Ausgehend davon, dass
die zuk�nftige Entwicklung im Bereich mobiler Endger�te nicht
stagniert, wird speziell nur auf die zum Zeitpunkt der Drucklegung
aktuelle Version der entsprechenden Spezifikation eingegangen. Die
einzige Ausnahme stellt die Bluetooth-Spezifikation dar, die lediglich
in der Version 1.2 vorgestellt wird, da die Mehrzahl der aktuell
verf�gbaren Endger�te lediglich diese Version unterst�tzt. Die
aktuelle Version (zum Zeitpunkt der Drucklegung v2.0) kann unter
<A HREF="https://www.bluetooth.org/spec/"><TT>https://www.bluetooth.org/spec/</TT></A> bezogen werden. Die �ltere
Version 1.1 der Bluetooth-Spezifikation, auf die der JSR-82 aufsetzt,
kann unter der selben URL angefordert werden.<BR>
<BR>
Die angesprochenen Technologien und Spezifikationen umfassen dabei:
<UL CLASS="itemize"><LI CLASS="li-itemize">
Connected Limited Device Configuration (Version 1.0 siehe
 [<A HREF="#sm:jsr30"><CITE>T+00</CITE></A>], Version 1.1 siehe [<A HREF="#sm:jsr139"><CITE>T+03</CITE></A>])
<LI CLASS="li-itemize">Mobile Information Device Profile (Version 1.0 siehe
 [<A HREF="#sm:jsr37"><CITE>Van00</CITE></A>], Version 2.0 siehe [<A HREF="#sm:jsr118"><CITE>VW02</CITE></A>])
<LI CLASS="li-itemize">Bluetooth (Spezifikation v1.2 siehe [<A HREF="#bt:spez12"><CITE>Blu03</CITE></A>])
<LI CLASS="li-itemize">Java APIs for Bluetooth Wireless Technology (JSR-82) [<A HREF="#sm:jsr82"><CITE>M+05</CITE></A>]
</UL>
<!--TOC section Bluetooth-->

<H2 CLASS="section"><A NAME="htoc8">2.1</A>&nbsp;&nbsp;Bluetooth</H2><!--SEC END -->

<A NAME="tgl:bt"></A>
<A NAME="@default5"></A>
<A NAME="@default6"></A>
Die im Folgenden beschriebenen Grundlagen beziehen sich auf die
Bluetooth-Spezifikation in der Version 1.2. Die �nderungen im
Vergleich zur Version 1.1 beziehen sich haupts�chlich auf die
Reduktion der Interferenzen mit anderen Funktechnologien und sind
deshalb minimal. Die Version 1.1 h�tte von der Bluetooth SIG speziell
angefordert werden m�ssen, was somit vermieden werden konnte, da die
Version 1.2 zum Zeitpunkt der Drucklegung ohne Registrierung
verf�gbar war. <BR>
<BR>
Die Bluetooth Funktechnologie ist ein Kurzstreckenfunkverfahren, das
prim�r dazu entwickelt wurde mobile Endger�te kabellos zu verbinden.
Das Bluetooth Grundsystem besteht aus Basisband,
Sende-/Empfangseinheit und dem zugeh�rigen
Protokollstapel<SUP><A NAME="text1" HREF="#note1">1</A></SUP>. Das Kurzstreckenfunkverfahren wird im weltweit
lizenzfreien 2.4 GHz ISM<SUP><A NAME="text2" HREF="#note2">2</A></SUP> Band betrieben. Um die Komplexit�t der Sende-
und Empfangseinheit gering zu halten und somit die Kosten zu
minimieren, wird als Modulationsverfahren dass
<A NAME="@default7"></A><I><FONT COLOR=maroon>Gaussian Frequency Shift Keying
 (GFSK)</FONT></I><SUP><A NAME="text3" HREF="#note3">3</A></SUP> eingesetzt (Vgl.&nbsp;: [<A HREF="#bt:spez12"><CITE>Blu03</CITE></A><CITE>, Architecture, S. 13; PDF, S.
89</CITE>]).<BR>
<BR>
Die Reichweite des Bluetooth-Kurzstreckenfunks ist, wie bei jeder
Funktechnologie, abh�ngig von der Sendeleistung des Ger�ts. Die
Sendeleistung &ndash; und somit auch die Reichweite &ndash; des Funks wird in
drei Klassen eingeteilt:<BR>
<BLOCKQUOTE CLASS="table"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
 <A NAME="@default8"></A><A NAME="@default9"></A><A NAME="@default10"></A>
 <A NAME="@default11"></A><A NAME="@default12"></A><A NAME="@default13"></A>
 <TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><SPAN STYLE="font-variant:small-caps">Klassifikation</SPAN></TD>
<TD ALIGN=left NOWRAP><SPAN STYLE="font-variant:small-caps">Reichweite</SPAN></TD>
<TD ALIGN=left NOWRAP><SPAN STYLE="font-variant:small-caps">Sendeleistung</SPAN></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>Klasse 1</TD>
<TD ALIGN=left NOWRAP>100 m</TD>
<TD ALIGN=left NOWRAP>100 mW</TD>
</TR>
<TR><TD ALIGN=left NOWRAP>Klasse 2</TD>
<TD ALIGN=left NOWRAP>40 m</TD>
<TD ALIGN=left NOWRAP>2.5 mW</TD>
</TR>
<TR><TD ALIGN=left NOWRAP>Klasse 3</TD>
<TD ALIGN=left NOWRAP>10 m</TD>
<TD ALIGN=left NOWRAP>1 mW</TD>
</TR></TABLE>
 <DIV CLASS="center">Tabelle 2.1: Reichweiten der einzelnen Bluetooth Klassen (Vgl.&nbsp;: [<A HREF="#wp:bt"><CITE>Wik06b</CITE></A>])</DIV>
 <A NAME="tgl:bt:reich"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Die Daten�bertragungsraten sind abh�ngig von der Spezifikation bzw.
der Bluetooth-Version des jeweiligen Produkts. Die �bertragungsrate
hat sich w�hrend der ersten drei Versionen nicht gesteigert, sie wurde
erst mit der Bluetooth-Spezifikation Version 2.0 erh�ht. Ein �berblick
�ber die �bertragungsraten, sowie die grossen �nderungen/Probleme, der
jeweilgen Bluetooth-Versionen ist in [Tab.: <A HREF="#tgl:bt:datarates">2.2</A>]
dargestellt.
<BLOCKQUOTE CLASS="table"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
 <A NAME="@default14"></A><A NAME="@default15"></A>
 <TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">Bluetooth-Version</SPAN></TD>
<TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">Maximale Daten�bertragungsrate</SPAN></TD>
<TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">�nderung/Problem</SPAN></TD>
</TR>
<TR><TD VALIGN=top ALIGN=left>1.0 und 1.0B</TD>
<TD VALIGN=top ALIGN=left>723.2 Kbit/s</TD>
<TD VALIGN=top ALIGN=left>Enth�lt Sicherheitsprobleme</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left>1.1</TD>
<TD VALIGN=top ALIGN=left>723.2 Kbit/s</TD>
<TD VALIGN=top ALIGN=left>Indikator f�r die Signalst�rke hinzugef�gt
 <I><FONT COLOR=maroon>Received Signal Strength Indicator</FONT></I>
 (RSSI)</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left>1.2</TD>
<TD VALIGN=top ALIGN=left>723.2 Kbit/s</TD>
<TD VALIGN=top ALIGN=left><I><FONT COLOR=maroon>Adaptive Frequency-Hopping spread
 spectrum</FONT></I> (AFH) eingef�hrt;
 reduziert Interferenzen mit anderen Funktechnologien (z.&nbsp;B. WLAN)</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left>2.0</TD>
<TD VALIGN=top ALIGN=left>2.1 Mbit/s</TD>
<TD VALIGN=top ALIGN=left>Etwa dreifache Daten�bertragungsgeschwindigkeit
 durch <I><FONT COLOR=maroon>Enhanced Data Rate</FONT></I> (EDR)</TD>
</TR></TABLE>
 <DIV CLASS="center">Tabelle 2.2: Daten�bertragungsraten von Bluetooth (Vgl.&nbsp;: [<A HREF="#wp:bt"><CITE>Wik06b</CITE></A><CITE>, Versionen</CITE>])</DIV>
 <A NAME="tgl:bt:datarates"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Der <A NAME="@default16"></A>Datentransport innerhalb der
Bluetooth-Architektur sowie s�mtliche Betriebsmodi folgen dem selben
generischen Ansatz. Dieser generische Ansatz ist mit Hilfe einer
Schichtenarchitektur realisiert, die in [Abb.: <A HREF="#tgl:bt:dta">2.1</A>]
dargestellt, und mit dem OSI-Schichtenmodell vergleichbar ist.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing001.gif"><DIV CLASS="center">Abbildung 2.1: Allgemeine Datentransport
 Architektur von Bluetooth (Vgl.&nbsp;: [<A HREF="#bt:spez12"><CITE>Blu03</CITE></A><CITE>, Architecture, S.25; PDF, S.
 101</CITE>])</DIV><A NAME="tgl:bt:dta"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
<!--TOC subsection Physical Layer-->

<H3 CLASS="subsection"><A NAME="htoc9">2.1.1</A>&nbsp;&nbsp;Physical Layer</H3><!--SEC END -->

<A NAME="tgl:bt:pl"></A> 
<A NAME="@default17"></A>
Der Physical Layer bestimmt die Art und Weise wie die Daten �bertragen
werden, bzw. wie die �bertragung der Daten stattzufinden hat. Er
spezifiziert bspw. was notwendig ist um Kollisionen zu vermeiden, oder
welches Verfahren verwendet wird um parallele Operationen zu
unterst�tzen.<BR>
<BR>
<!--TOC subsubsection Physical Channel-->

<H4 CLASS="subsubsection"><A NAME="htoc10">2.1.1.1</A>&nbsp;&nbsp;Physical Channel</H4><!--SEC END -->

<A NAME="tgl:bt:pl:pc"></A> 
<A NAME="@default18"></A><BR>
<BR>
<DIV style="float: left; margin: 0ex 1.5ex 0ex 0ex;"><IMG SRC="ObexObjectPassing002.gif"></DIV> Auf der
untersten Ebene dieser Architektur befindet sich der <I><FONT COLOR=maroon>Physical
Channel</FONT></I>. Er wird von zwei Bluetooth Ger�ten zur Kommunikation
genutzt. Um miteinander kommunizieren zu k�nnen, m�ssen beide Sende-
und Empfangseinheiten in Reichweite sein und auf die selbe
Funkfrequenz eingestellt werden. <A NAME="@default19"></A>Um
unbeabsichtigte Kollisionen zu vermeiden wird der Kommunikation ein
Zugriffscode angef�gt. Dies verhindert Kollisionen, w�rden mehrere
Ger�te auf die selbe Frequenz eingestellt werden. In der
Spezifikation sind vier physische Kan�le definiert, von denen jeder
f�r einen bestimmten Anwendungszweck definiert und optimiert wurde.
Um parallele Operationen zu unterst�tzen, wird das <I><FONT COLOR=maroon>Time Division
Multiplexing</FONT></I><SUP><A NAME="text4" HREF="#note4">4</A></SUP> Verfahren verwendet.
Durch diesen Mechanismus wird es erm�glicht, dass das Ger�t w�hrend
einer bestehenden Kommunikation auffindbar und zug�nglich ist. Die
Spezifikation nimmt weiterhin an, dass das Ger�t lediglich in der Lage
ist, sich ausschliesslich mit einem �bertragungskanal zu verbinden
(Vgl.&nbsp;: [<A HREF="#bt:spez12"><CITE>Blu03</CITE></A><CITE>, Architecture, S. 32; PDF, S. 108</CITE>]).<BR>
<BR>
<!--TOC subsubsection Physical Links-->

<H4 CLASS="subsubsection"><A NAME="htoc11">2.1.1.2</A>&nbsp;&nbsp;Physical Links</H4><!--SEC END -->

<A NAME="tgl:bt:pl:plink"></A> 
<A NAME="@default20"></A><BR>
<BR>
<DIV style="float: left; margin: 0ex 1.5ex 0ex 0ex;"><IMG SRC="ObexObjectPassing003.gif"></DIV> Der
<I><FONT COLOR=maroon>Physical Link</FONT></I> repr�sentiert die
Basisbandverbindung<SUP><A NAME="text5" HREF="#note5">5</A></SUP> zwischen den Endger�ten. Eine solche physische
Verbindung ist immer mit genau einem physischen Kanal verkn�pft,
obwohl ein physischer Kanal mehr als eine physische Verbindung
unterst�tzen kann. Die physische Verbindung ist innerhalb eines
Bluetooth-Systems lediglich ein virtuelles Konzept. Innerhalb eines
Bluetooth-Pakets existiert kein Feld, welches es erm�glichen w�rde die
physische Verbindung direkt zu identifizieren. Die physische
Verbindung kann stattdessen �ber den logischen
Transportkanal<SUP><A NAME="text6" HREF="#note6">6</A></SUP> identifiziert werden. Physische Verbindungen
haben �blicherweise gemeinsame Eigenschaften, die auf alle logischen
Transportkan�le &ndash; die zu dieser Verbindung geh�ren &ndash; angewandt werden.
Beispiele solcher Eigenschaften sind die Verschl�sselung und
Leistungssteuerung <I><FONT COLOR=maroon>(Power Control)</FONT></I> des Ger�ts. Soll eine
�bertragung �ber mehrere physische Verbindungen hinweg ausgel�st
werden <I><FONT COLOR=maroon>(Broadcast)</FONT></I>, werden die Sendeparameter entsprechend
angepasst, sodass auf allen physischen Verbindungen gesendet werden
kann (Vgl.&nbsp;: [<A HREF="#bt:spez12"><CITE>Blu03</CITE></A><CITE>, Architecture, S. 37; PDF: S. 113</CITE>]).<BR>
<BR>

<!--TOC subsection Logical Layer-->

<H3 CLASS="subsection"><A NAME="htoc12">2.1.2</A>&nbsp;&nbsp;Logical Layer</H3><!--SEC END -->

<A NAME="tgl:bt:ll"></A> 
<A NAME="@default21"></A>
Der <I><FONT COLOR=maroon>Logical Layer</FONT></I> definiert, wie die logischen
Transportverbindungen physisch zugeordnet werden.<BR>
<BR>
<!--TOC subsubsection Logical Transports-->

<H4 CLASS="subsubsection"><A NAME="htoc13">2.1.2.1</A>&nbsp;&nbsp;Logical Transports</H4><!--SEC END -->

<A NAME="tgl:bt:pl:lt"></A> 
<A NAME="@default22"></A>
<DIV style="float: left; margin: 0ex 1.5ex 0ex 0ex;"><IMG SRC="ObexObjectPassing004.gif"></DIV> Zwischen
<I><FONT COLOR=maroon>Master</FONT></I> und <I><FONT COLOR=maroon>Slave</FONT></I> &ndash; <I><FONT COLOR=maroon>Master</FONT></I> und <I><FONT COLOR=maroon>Slave</FONT></I> ist
das Analogon zum Client-/Server-Modell bei Protokollen wie z.&nbsp;B. FTP &ndash; k�nnen verschiedene
Typen von logischen Transportverbindungen (<I><FONT COLOR=maroon>Logical Transports</FONT></I>)
hergestellt werden. Dabei ist es jedem Ger�t m�glich, den
<I><FONT COLOR=maroon>Master</FONT></I> oder <I><FONT COLOR=maroon>Slave</FONT></I> Status einzunehmen; der Status kann
sogar w�hrend der bestehenden Verbindung gewechselt werden. Logische
Transportverbindungen werden von aktiven physischen Verbindungen
getragen und sind in der Lage, verschiedene Arten logischer
Verbindungen zu beinhalten (Vgl.&nbsp;: [<A HREF="#bt:spez12"><CITE>Blu03</CITE></A><CITE>, Architectur, S. 39f; PDF, S.
115f</CITE>]).<BR>
<BR>
In der Spezifikation sind f�nf logische Transportverbindungen zwischen
<I><FONT COLOR=maroon>Master</FONT></I> und <I><FONT COLOR=maroon>Slave</FONT></I> definiert:
<UL CLASS="itemize"><LI CLASS="li-itemize">
 <I><FONT COLOR=maroon>Synchronous Connection-Oriented
 (SCO) logical transport</FONT></I>
 <LI CLASS="li-itemize"><I><FONT COLOR=maroon>Extended Synchronous Connection-Oriented
 (eSCO) logical transport</FONT></I>
 <LI CLASS="li-itemize"><I><FONT COLOR=maroon>Asynchronous Connection-Oriented
 (ACL) logical transport</FONT></I>
 <LI CLASS="li-itemize"><I><FONT COLOR=maroon>Active Slave Broadcast (ASB) logical transport</FONT></I>
 <LI CLASS="li-itemize"><I><FONT COLOR=maroon>Parked Slave Broadcast (PSB) logical transport</FONT></I>
 </UL>
Die synchronen Transportverbindungen stellen hierbei
 Punkt-zu-Punkt-Verbindungen von einem <I><FONT COLOR=maroon>Master</FONT></I> zu einem
 <I><FONT COLOR=maroon>Slave</FONT></I> dar. Sie unterst�tzen typischerweise zeitabh�ngige
 Informationen wie z.&nbsp;B. Sprache. Das Master-Ger�t regelt hierbei die
 Verbindung indem es reservierte <I><FONT COLOR=maroon>Slots</FONT></I> in regelm��igen
 Abst�nden benutzt. Die ACL Verbindungen stellen ebenfalls eine
 Punkt-zu-Punkt-Verbindung zwischen einem <I><FONT COLOR=maroon>Master</FONT></I> und einem
 <I><FONT COLOR=maroon>Slave</FONT></I> dar. Der <I><FONT COLOR=maroon>Master</FONT></I> kann die ACL Verbindung zu einem
 beliebigen <I><FONT COLOR=maroon>Slave</FONT></I> &ndash; inklusive der <I><FONT COLOR=maroon>Slaves</FONT></I> die bereits
 eine bestehende synchrone Verbindung haben &ndash; herstellen, indem er
 die <I><FONT COLOR=maroon>Slots</FONT></I> benutzt, die nicht f�r die synchrone Verbindung
 reserviert sind. Eine genaue Beschreibung der einzelnen
 Transportverbindungen ist unter [<A HREF="#bt:spez12"><CITE>Blu03</CITE></A><CITE>, Baseband Specification, S.
 85ff; PDF, S.243ff</CITE>] zu finden.<BR>
<BR>
<!--TOC subsubsection Logical Links-->

<H4 CLASS="subsubsection"><A NAME="htoc14">2.1.2.2</A>&nbsp;&nbsp;Logical Links</H4><!--SEC END -->

<A NAME="tgl:bt:pl:ll"></A> 
<A NAME="@default23"></A><BR>
<BR>
<DIV style="float: left; margin: 0ex 1.5ex 0ex 0ex;"><IMG SRC="ObexObjectPassing005.gif"></DIV> Um die
verschiedenen Anforderungen einer Applikation bez�glich dem
Datentransport abzudecken, ist eine Vielzahl logischer Verbindungen
(<I><FONT COLOR=maroon>Logical Links</FONT></I>) verf�gbar. Jede logische Verbindung wird mit
einer logischen Transportverbindung assoziiert, die �ber verschiedene
Charakteristika verf�gt. Diese beinhalten z.&nbsp;B. Flusskontrolle,
Sequenznummerierung sowie die Ablaufkoordination <I><FONT COLOR=maroon>(Scheduling)</FONT></I>.
Innerhalb einer logischen Transportverbindung kann die logische
Verbindung anhand des <I><FONT COLOR=maroon>Logical Link Identifiers
(LLID)</FONT></I>
erkannt werden, der im Header eines Basisbandpakets zu
finden ist (Vgl.&nbsp;: [<A HREF="#bt:spez12"><CITE>Blu03</CITE></A><CITE>, Architectur, S. 46f; PDF,
S. 122f</CITE>]).<BR>
<BR>
Die folgenden f�nf logischen Verbindungen sind in der Spezifikation
definiert (Vgl.&nbsp;: [<A HREF="#bt:spez12"><CITE>Blu03</CITE></A><CITE>, Baseband Specification, S. 95ff; PDF, S.
253ff</CITE>])
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description">
<A NAME="@default24"></A><B>Link Control (LC)</B><DD CLASS="dd-description">
 Diese logische Verbindung tr�gt Kontrollinformationen der unteren
 Ebenen, wie z.&nbsp;B. <I><FONT COLOR=maroon>Acknowledgement/Repeat Request
 (ARQ)</FONT></I>,
 Flusskontrolle und Nutzlastcharakterisierungen.
<DT CLASS="dt-description"><A NAME="@default25"></A><B>ACL Control (ACL-C)</B><DD CLASS="dd-description"> Die ACL-C
 Verbindung tr�gt Kontrollinformationen, die zwischen den <I><FONT COLOR=maroon>Link
 Managern (LM)</FONT></I><SUP><A NAME="text7" HREF="#note7">7</A></SUP> der Endger�te
 ausgetauscht werden m�ssen. Der Austausch dieser Informationen
 geschieht �ber das <I><FONT COLOR=maroon>Link Manager Protokoll
 (LMP)</FONT></I>.
<DT CLASS="dt-description"><A NAME="@default26"></A><B>User
 Asynchronous/Isochronous (ACL-U)</B><DD CLASS="dd-description"> Die ACL-U Verbindung tr�gt
 asynchrone, sowie isochrone L2CAP Benutzerdaten. Diese Nachrichten
 k�nnen in einem oder mehreren Paketen �bermittelt werden. Bei
 fragmentierten Daten wird im Header der LLID auf den entsprechenden
 Wert gesetzt.
<DT CLASS="dt-description"><A NAME="@default27"></A><B>User Synchronous
 (SCO-S)</B><DD CLASS="dd-description"> Die SCO-S Verbindung
 transportiert synchrone Benutzerdaten.
<DT CLASS="dt-description"><A NAME="@default28"></A><B>User Extended Synchronous
 (eSCO-S)</B><DD CLASS="dd-description"> Die eSCO-S
 Verbindung transportiert ebenfalls synchrone Benutzerdaten.
</DL>

<!--TOC subsection L2CAP Layer-->

<H3 CLASS="subsection"><A NAME="htoc15">2.1.3</A>&nbsp;&nbsp;L2CAP Layer</H3><!--SEC END -->

<A NAME="tgl:bt:l2cap"></A> 
<A NAME="@default29"></A><BR>
<BR>
<DIV style="float: left; margin: 0ex 1.5ex 0ex 0ex;"><IMG SRC="ObexObjectPassing006.gif"></DIV> Das
 <I><FONT COLOR=maroon>Logical Link Control and Adaption Protocol
 (L2CAP)</FONT></I> unterst�tzt Multiplexing zu Protokollen h�herer
 Ebenen, Paketsegmentierung und -reassemblierung, sowie das
 �bermitteln von <I><FONT COLOR=maroon>Quality of Service</FONT></I><SUP><A NAME="text8" HREF="#note8">8</A></SUP> Informationen. Applikationen und
 Service-Protokolle kommunizieren mit dem L2CAP-Layer �ber ein
 sogenanntes <I><FONT COLOR=maroon>Channel-Orientated Interface</FONT></I>, um Verbindungen zu
 anderen Ger�ten herzustellen. Die entsprechenden Endpunkte werden
 �ber einen <I><FONT COLOR=maroon>Channel Identifier (CID)</FONT></I> gekennzeichnet, dessen Wert vom L2CAP-Layer zugewiesen
 wird. Das Hauptaugenmerk des L2CAP-Layers liegt aber auf dessen
 Multiplexing-F�higkeit. Er ist daf�r zust�ndig, dass die �ber das
 <I><FONT COLOR=maroon>Channel Interface</FONT></I> ankommenden Daten (<I><FONT COLOR=maroon>Service Data Units
 [SDUs]</FONT></I>) auf die ACL-U
 Verbindungen verteilt werden. Ist ein HCI<SUP><A NAME="text9" HREF="#note9">9</A></SUP>
 vorhanden, hat der L2CAP-Layer ebenfalls daf�r Sorge zu tragen, dass
 die Daten entprechend der Puffergr�sse des Basisbands segmentiert
 werden (Vgl.&nbsp;: [<A HREF="#bt:spez12"><CITE>Blu03</CITE></A><CITE>, Architectur, S. 48; PDF, S. 124</CITE>]).<BR>
<BR>

<!--TOC subsection Bluetooth Sicherheit-->

<H3 CLASS="subsection"><A NAME="htoc16">2.1.4</A>&nbsp;&nbsp;Bluetooth Sicherheit</H3><!--SEC END -->

<A NAME="tgl:bt:sec"></A>
<A NAME="@default30"></A>
<A NAME="@default31"></A>
Die Bluetooth-Spezifikation beschreibt das Sicherheitssystem, das
bereits auf der Verbindungsebene <I><FONT COLOR=maroon>(Link Layer)</FONT></I> angewendet wird,
sehr ausf�hrlich. Verschl�sselung, Authentifizierung sowie
Schl�sselerzeugungsschemata und die Erzeugung von Zufallszahlen sind
spezifiziert. Die Authentifizierungs- und Verschl�sselungsalgorithmen
m�ssen in jedem Ger�t eine �quivalente Implementierung aufweisen. 
Um die Sicherheit auf der Verbindungsebene zu realisieren, werden die
vier in [Tab.: <A HREF="#tgl:bt:sec:ave">2.3</A>] aufgef�hrten Entit�ten verwendet.
<BLOCKQUOTE CLASS="table"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
 <TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">Entit�t</SPAN></TD>
<TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">Gr�sse</SPAN></TD>
</TR>
<TR><TD VALIGN=top ALIGN=left><I><FONT COLOR=maroon>Bluetooth Device Address (BD_ADDR)</FONT></I></TD>
<TD VALIGN=top ALIGN=left>48 Bit</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left>Privater Schl�ssel des Benutzers (Authentifizierung)</TD>
<TD VALIGN=top ALIGN=left>128
 Bit</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left>Privater Schl�ssel des Benutzers (Verschl�sselung)</TD>
<TD VALIGN=top ALIGN=left>8-128
 Bit</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left>Pseudozufallszahl
 (RAND)</TD>
<TD VALIGN=top ALIGN=left>128 Bit</TD>
</TR></TABLE>
<DIV CLASS="center">Tabelle 2.3: In Authentifizierung und Verschl�sselung involvierte
 Entit�ten (Vgl.&nbsp;: [<A HREF="#bt:spez12"><CITE>Blu03</CITE></A><CITE>, Security Specification, S. 749; PDF, S. 907
 Tabelle 1.1</CITE>])</DIV>
<A NAME="tgl:bt:sec:ave"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Die Authentifizierung beider Ger�te erfolgt in zwei Schritten, das
heisst es wird eine gegenseitige Authentifizierung beider Ger�te
vorgenommen. In direktem Anschluss der Authentifizierung des Ger�ts A
bei Ger�t B wird die Authentifizierung in entgegengesetzter Richtung
vorgenommen<SUP><A NAME="text10" HREF="#note10">10</A></SUP> (Vgl.&nbsp;: [<A HREF="#bt:spez12"><CITE>Blu03</CITE></A><CITE>, Security Specification, S. 758;
PDF, S. 914</CITE>]).<BR>
<BR>
Benutzerdaten k�nnen mittels des angebotenen
Verschl�sselungsalgorithmus gesch�tzt werden. Es werden jedoch
lediglich die Nutzdaten des zu sendenden Pakets verschl�sselt. Der
Header des Pakets bleibt unangetastet. Der Algorithmus
implementiert eine Stromchiffrierung mit Hilfe der SAFER+
Methode, die frei erh�ltlich ist. Sie ist eine verbesserte
Version des SAFER<SUP><A NAME="text11" HREF="#note11">11</A></SUP>
Algorithmus [<A HREF="#bt:spez12"><CITE>Blu03</CITE></A><CITE>, Security Specification, S. 777ff; PDF, S.
935ff</CITE>]. <BR>
<BR>

<!--TOC subsection Generic Access Profile (GAP)-->

<H3 CLASS="subsection"><A NAME="htoc17">2.1.5</A>&nbsp;&nbsp;Generic Access Profile (GAP)</H3><!--SEC END -->

<A NAME="tgl:bt:gap"></A>
<A NAME="@default32"></A>
<A NAME="@default33"></A>
Sinn und Zweck des <I><FONT COLOR=maroon>Generic Access Profiles
(GAP)</FONT></I> ist es,
Definitionen, Empfehlungen sowie allgemeine Anforderungen in Bezug auf
verschiedene Betriebsmodi und Zugriffsprozeduren zu beschreiben, die
von Transport- und Applikationsprofilen verwendet werden sollten. Es
wird weiterhin beschrieben, wie sich die Ger�te im Ruhe- und im
Verbindungsaufbauzustand verhalten sollten. Speziell wird der Fokus
hierbei auf die Ger�tesuche, Erzeugung der Verbindung sowie die
Sicherheitsprozeduren gelegt. Das Schichtenmodell des GAP folgt dem
in [Abb.: <A HREF="#tgl:bt:gap:stack">2.2</A>] dargestellten Aufbau [<A HREF="#bt:spez12"><CITE>Blu03</CITE></A><CITE>, Generic
Access Profile, S. 179ff; PDF: S. 1127ff</CITE>].
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing007.gif"><DIV CLASS="center">Abbildung 2.2: GAP Schichtenmodell (Vgl.: Abbildung 2.1: Profile stack
covered by this profile, S. 181 [<A HREF="#bt:spez12"><CITE>Blu03</CITE></A>])</DIV><A NAME="tgl:bt:gap:stack"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Die Spezifikation des GAP besch�ftigt sich haupts�chlich damit, zu
beschreiben, welchem Zweck die unteren Schichten des Bluetooth
Protokollstapels dienen (LC und LMP). Um Sicherheitsbezogene
Alternativen zu diskutieren, wurden ebenfalls h�here Ebenen mit
einbezogen (L2CAP, RFCOMM und OBEX) [<A HREF="#bt:spez12"><CITE>Blu03</CITE></A><CITE>, Generic Access Profile, S.
181; PDF: S. 1129</CITE>].<BR>
<BR>
<A NAME="@default34"></A> <A NAME="@default35"></A> <A NAME="@default36"></A>
<A NAME="@default37"></A> <A NAME="@default38"></A>
<A NAME="@default39"></A>
<A NAME="@default40"></A> <BR>
<BR>
In Bezug auf eine Suchanfrage <I><FONT COLOR=maroon>(inquiry)</FONT></I> kann sich ein
Bluetooth-Ger�t in drei verschiedenen Zust�nden befinden. Die
m�glichen Zust�nde sind in [Tab.: <A HREF="#tgl:bt:gap:disc">2.4</A>] abgedruckt.
<BLOCKQUOTE CLASS="table"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
 <TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">Auffindbarkeitszustand</SPAN></TD>
<TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">Beschreibung</SPAN></TD>
</TR>
<TR><TD VALIGN=top ALIGN=left><I><FONT COLOR=maroon>Non-discoverable mode</FONT></I></TD>
<TD VALIGN=top ALIGN=left>Ist das Ger�t in diesem Zustand, so
 kann es von einer Suchanfrage nicht gefunden werden. Ein
 Bluetooth-Ger�t in diesem Zustand wird als &#8220;Stilles Ger�t&#8221;
 <I><FONT COLOR=maroon>(silent device)</FONT></I> bezeichnet.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left><I><FONT COLOR=maroon>Limited discoverable mode (LIAC)</FONT></I></TD>
<TD VALIGN=top ALIGN=left>Das Ger�t ist f�r einen beschr�nkten Zeitraum
 oder bis zum Eintritt eines bestimmten Ereignisses auffindbar. Es
 sollte allerdings nicht l�nger als eine vordefinierte Zeit 
 in diesem Zustand bleiben <I><FONT COLOR=maroon>(timeout)</FONT></I>. Ist ein Ger�t in
 diesem Zustand, antwortet es auf Suchanfragen die den <I><FONT COLOR=maroon>Limited Dedicated Inquiry Access
 Code (LIAC)</FONT></I> verwenden.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left><I><FONT COLOR=maroon>General discoverable mode
 (GIAC)</FONT></I></TD>
<TD VALIGN=top ALIGN=left>Das Ger�t befindet sich in einem dauerhaft
 auffindbaren Zustand. Ist ein Ger�t in
 diesem Zustand, antwortet es auf Suchanfragen die den <I><FONT COLOR=maroon>General/Unlimited Inquiry Access
 Code (GIAC)</FONT></I> verwenden.</TD>
</TR></TABLE>
 <DIV CLASS="center">Tabelle 2.4: Auffindbarkeitszust�nde eines Bluetooth-Ger�ts
 [<A HREF="#sm:jsr82"><CITE>M+05</CITE></A><CITE>, Generic Access Profile, S. 189ff; PDF, S.1137ff</CITE>]</DIV>
<A NAME="tgl:bt:gap:disc"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Die spezifizierten Werte der Zugriffskennzeichner LIAC und GIAC sind
auf der Bluetooth Homepage<SUP><A NAME="text12" HREF="#note12">12</A></SUP>
zu finden [<A HREF="#btsig:anbb"><CITE>Blu06</CITE></A>]. 

<!--TOC subsection Bluetooth Implementierungen-->

<H3 CLASS="subsection"><A NAME="htoc18">2.1.6</A>&nbsp;&nbsp;Bluetooth Implementierungen</H3><!--SEC END -->

<A NAME="tgl:bt:stackimpl"></A>
<A NAME="@default41"></A>
Um Bluetooth auf einem Ger�t verwenden zu k�nnen ist es notwendig,
dass eine &ndash; zur Hardware passende &ndash; Implementierung eines
Bluetooth-Stacks bereitgestellt wird. F�r die mobilen Endger�te ist in
den meisten F�llen eine Bluetooth Implementierung des jeweiligen
Herstellers auf dem Ger�t vorhanden. Um allerdings auf einem
Desktop-System Bluetooth-Unterst�tzung zu erhalten, muss i.&nbsp;d.&nbsp;R. ein
entsprechender Stack nachtr�glich installiert werden.


<!--TOC section Java 2 Micro Edition (J2ME)-->

<H2 CLASS="section"><A NAME="htoc19">2.2</A>&nbsp;&nbsp;Java 2 Micro Edition (J2ME)</H2><!--SEC END -->

<A NAME="tgl:j2me"></A>
<A NAME="@default42"></A>
Die <I><FONT COLOR=maroon>Java 2 Platform, Micro Edition
 (J2ME )</FONT></I> ist eine Plattform, die speziell auf die
Bed�rfnisse von <I><FONT COLOR=maroon>Embedded Devices</FONT></I> zugeschnitten ist. Die J2ME
Architektur definiert Konfigurationen, Profile sowie optionale Pakete,
mit deren Hilfe es m�glich ist, Java Laufzeitumgebungen zu entwickeln,
die eine m�glichst breite Palette an Endger�ten des jeweiligen
Zielmarktes abdecken. Konfigurationen bestehen aus der Kombination
einer virtuellen Maschine (VM) sowie einem zugeh�rigen minimalen Set an
Klassenbibliotheken. Um eine komplette Laufzeitumgebung f�r
dom�nenspezifische Endger�te zu schaffen, muss die Konfiguration um ein
Set zus�tzlicher Klassenbibliotheken erweitert werden, die in einem
Profil oder optionalen Paket definiert sind. Die J2ME Plattform
l�sst sich, wie in [Abb.: <A HREF="#tgl:j2me:ein">2.3</A>] dargestellt, im Java Umfeld
einordnen (Vgl.&nbsp;: [<A HREF="#sm:j2me"><CITE>Sun06</CITE></A>]).
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing008.gif"><DIV CLASS="center">Abbildung 2.3: Einordnung von J2ME im Java
 Umfeld (Vgl.&nbsp;: [<A HREF="#sm:j2me"><CITE>Sun06</CITE></A>])</DIV><A NAME="tgl:j2me:ein"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Die J2ME Architektur folgt also prinzipiell dem in
[Abb.: <A HREF="#tgl:j2me:arch">2.4</A>] dargestellten Aufbau. Die einzelnen
Schichten der Architektur (CLDC [Kapitel <A HREF="#tgl:cldc">2.3</A>] und MIDP
[Kapitel <A HREF="#tgl:midp">2.4</A>]) werden im Folgenden genauer beschrieben.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing009.gif"><DIV CLASS="center">Abbildung 2.4: J2ME Architektur (Vgl.&nbsp;: [<A HREF="#sm:jsr139"><CITE>T+03</CITE></A><CITE>, Abb. 1, S.
 28</CITE>])</DIV><A NAME="tgl:j2me:arch"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>

<!--TOC section Connected Limited Device Configuration (CLDC)-->

<H2 CLASS="section"><A NAME="htoc20">2.3</A>&nbsp;&nbsp;Connected Limited Device Configuration (CLDC)</H2><!--SEC END -->

<A NAME="tgl:cldc"></A>
<A NAME="@default43"></A>
<A NAME="@default44"></A>
<A NAME="@default45"></A><BR>
<BR>
<DIV style="float: left; margin: 0ex 1.5ex 0ex 0ex;"><IMG SRC="ObexObjectPassing010.gif"></DIV> Die
<I><FONT COLOR=maroon>Connected Limited Device Configuration
 (CLDC)</FONT></I> stellt, zusammen mit dem <I><FONT COLOR=maroon>Mobile
 Information Device Profile (MIDP)</FONT></I><SUP><A NAME="text13" HREF="#note13">13</A></SUP>, die Grundlage der J2ME dar. Wie nahezu alle
Standards rund um Java, ist die CLDC ebenfalls Ergebnis eines
<I><FONT COLOR=maroon>Java Specification Request (JSR)</FONT></I>. Die CLDC 1.0 wird als JSR-30 [<A HREF="#sm:jsr30"><CITE>T+00</CITE></A>], die
Version 1.1 als JSR-139 [<A HREF="#sm:jsr139"><CITE>T+03</CITE></A>] gef�hrt<SUP><A NAME="text14" HREF="#note14">14</A></SUP>. Die
CLDC 1.1 ist nicht als komplette Neuerung, sondern lediglich als
Erweiterung der CLDC 1.0 zu sehen. Das bedeutet, dass die CLDC 1.1,
mit ein paar wenigen Ausnahmen wie z.&nbsp;B. der Unterst�tzung f�r
Gleitpunktoperationen, abw�rtskompatibel zur CLDC 1.0 ist. Die CLDC
Spezifikation hat zum Ziel, eine Entwicklungsplattform f�r
netzwerkf�hige, jedoch in ihren Ressourcen limitierte, portable,
Ger�te zu standardisieren. Solche Ger�te sind bspw. ein Mobiltelefon
oder ein Personal Digital Assistant (PDA). Eine Konfiguration der J2ME Plattform spezifiziert
hierbei die Basismenge der Java Programmiersprache sowie die
Funktionalit�t der zugeh�rigen VM. <I><FONT COLOR=maroon>Sun Microsystems, Inc.</FONT></I>
bietet eine Referenzimplementierung einer solchen virtuellen Maschine
an, die in der Spezifikation als <I><FONT COLOR=maroon>K Virtual Machine
 (KVM)</FONT></I> bezeichnet wird, aber
mittlerweile unter der Bezeichnung <I><FONT COLOR=maroon>CLDC HotSpot
 Implementation Virtual
 Machine</FONT></I><SUP><A NAME="text15" HREF="#note15">15</A></SUP> bekannt
ist, die die 8-10 fache Geschwindigkeit der KVM erreicht. Die CLDC
dient als Basis f�r ein oder mehrere Profile, die ein dem Ger�t
entsprechendes API anbieten (Vgl.&nbsp;: [<A HREF="#sm:jsr139"><CITE>T+03</CITE></A><CITE>, S. xi</CITE>]).<BR>
<BR>
Da die CLDC darauf ausgerichtet wurde, eine m�glichst grosse Anzahl
verschiedener Ger�te zu unterst�tzen, besitzt sie, ausser der
Mindestanforderung an den Speicher, keine weiteren Anforderungen bzgl.
der zu Grunde liegenden Hardware. Typischerweise besitzen die
angesprochenen Ger�te jedoch <A NAME="@default46"></A>
<A NAME="@default47"></A> limitierte Ressourcen:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<A NAME="tgl:cldc:hwr"></A>
160 Kilobyte nichtfl�chtiger Speicher
<LI CLASS="li-itemize">32 Kilobyte fl�chtiger Speicher
<LI CLASS="li-itemize">16 Bit oder 32 Bit Prozessor
<LI CLASS="li-itemize">M�glichkeit, eine Verbindung zu einem Netzwerk herzustellen
</UL>
In keinem Fall ist die CLDC mit der <I><FONT COLOR=maroon>Connected Device
 Configuration (CDC)</FONT></I><SUP><A NAME="text16" HREF="#note16">16</A></SUP> zu
verwechseln, die einen erheblich gr�sseren Umfang als die CLDC bietet.
Innerhalb der CDC ist z.&nbsp;B. der Mechanismus der Serialisierung und
Deserialisierung von Objekten implementiert, was in der CLDC nicht der
Fall ist. Die CDC ist f�r portable High-End-Ger�te entwickelt worden.<BR>
<BR>
Die Implementierung der CLDC kann keine Kenntnis eines Dateisystems
auf dem Endger�t voraussetzen. Viele, in ihren Ressourcen
eingeschr�nkte Ger�te, verf�gen nicht �ber die Kenntnis eines
<A NAME="tgl:cldc:fs"></A>Dateisystems oder �hnlichem, welches es erm�glicht
dynamisch bezogene Daten persistent auf dem Ger�t zu speichern. Die
Implementierung muss lediglich in der Lage sein, die Applikation zu
laden und sie direkt nach ihrer Ausf�hrung wieder zu verwerfen.
Verf�gt das Ger�t allerdings �ber einen Persistenzmechanismus, ist es
Aufgabe des Betriebssystems, einen Mechanismus zur Verwaltung der
Applikationen zur Verf�gung zu stellen. Auf Grund der variablen
Bandbreite verf�gbarer Ger�te, ist ein solcher Mechanismus allerdings
stark abh�ngig vom Ger�t selbst und wird aufgrunddessen nicht von der
Spezifikation behandelt (Vgl.&nbsp;: [<A HREF="#sm:jsr139"><CITE>T+03</CITE></A><CITE>, S. 29</CITE>]).<BR>
<BR>
<!--TOC subsection Generic Connection Framework (GCF)-->

<H3 CLASS="subsection"><A NAME="htoc21">2.3.1</A>&nbsp;&nbsp;Generic Connection Framework (GCF)</H3><!--SEC END -->

<A NAME="tgl:cldc:gcf"></A>
<A NAME="@default48"></A>
In einer einheitlichen, erweiterbaren Art und Weise bietet das
<I><FONT COLOR=maroon>Generic Connection Framework (GCF)</FONT></I> die
M�glichkeit, auf Ein- und Ausgabeoperationen sowie Netzwerkressourcen
zuzugreifen. Anstatt auf eine Vielzahl verschiedener
Abstraktionsmechanismen f�r jeden Kommunikationstyp zur�ckzugreifen,
wird eine Menge zugeh�riger Abstraktionen auf Ebene der
Applikationsprogrammierung benutzt. Dieser generische Mechanismus besitzt
folgende Form: <BR>
<BR>
<TT>Connector.open(&#0171;protocol&gt;:&lt;address&gt;;&lt;parameters&gt;");</TT><BR>
<BR>
Das GCF, das in der CLDC spezifiziert wird, definiert allerdings kein
zwingend zu unterst�tzendes Netzwerkprotokoll. Sie fordert ebensowenig
eine Implementierung bereits bestehender Protokolle. Sie bietet jedoch
ein erweiterbares Rahmenwerk, das von J2ME Profilen, wie z.&nbsp;B. dem
MIDP<SUP><A NAME="text17" HREF="#note17">17</A></SUP> angepasst werden kann. Die
tats�chliche Implementierung der entsprechenden Protokolle erfolgt
also auf Ebene des Profils (Vgl.: [<A HREF="#sm:jsr139"><CITE>T+03</CITE></A><CITE>, S. 56ff</CITE>]).

<!--TOC subsection CLDC Sicherheit-->

<H3 CLASS="subsection"><A NAME="htoc22">2.3.2</A>&nbsp;&nbsp;CLDC Sicherheit</H3><!--SEC END -->

<A NAME="tgl:cldc:sec"></A>
<A NAME="@default49"></A>
<A NAME="@default50"></A>
Das von der J2SE bekannte, sehr m�chtige, Sicherheitsmodell konnte
aufgrund des Code-Umfangs nicht �bernommen werden, da es die
spezifizierten Speichergrenzen der CLDC bei weitem �berschreitet. Das
Sicherheitsmodell ist deshalb in drei verschiedene Ebenen eingeteilt.
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description">
<A NAME="@default51"></A>
<A NAME="@default52"></A>
<B>Low-level security</B><DD CLASS="dd-description"> Der Begriff <I><FONT COLOR=maroon>low-level security</FONT></I> ist
 auch unter der Bezeichnung <I><FONT COLOR=maroon>Virtual machine security</FONT></I> bekannt.
 <I><FONT COLOR=maroon>Low-level security</FONT></I> stellt sicher, dass Applikationen, die in
 der VM ausgef�hrt werden, die Semantik der Java Programmiersprache
 einhalten. Sie stellt weiterhin sicher, dass jedweder fehlerhafte
 oder sch�dliche Programm-Code nicht in der Lage ist, das Ger�t zu
 besch�digen oder es zum Absturz zu bringen (Vgl.&nbsp;: [<A HREF="#sm:jsr139"><CITE>T+03</CITE></A><CITE>, S.
 30</CITE>]). <A NAME="@default53"></A>
 <A NAME="@default54"></A>
<A NAME="tgl:cldc:sec:als"></A>
<DT CLASS="dt-description"><B>Application-level security</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Application-level security</FONT></I>
 bedeutet, dass die Applikation nur auf Ressourcen, Bibliotheken und
 andere Komponenten zugreifen kann, die von der Java Laufzeitumgebung
 und dem Ger�t genehmigt worden sind. Realisiert wird das durch ein
 sogenanntes Sandbox-Modell. Es muss gew�hrleisten, dass Java
 Applikationen nicht aus ihrer Sandbox ausbrechen k�nnen. Das
 CLDC Sandbox-Modell verbietet ebenfalls ein herunterladen beliebiger
 neuer Bibliotheken, die nicht zum Umfang der Java Bibliotheken der
 CLDC oder des Herstellers geh�ren. Das Ausf�hren nativen Codes ist
 ebenfalls verboten (Vgl.&nbsp;: [<A HREF="#sm:jsr139"><CITE>T+03</CITE></A><CITE>, S. 31</CITE>]).
<A NAME="@default55"></A>
<A NAME="@default56"></A>
<DT CLASS="dt-description"><B>End-to-end security</B><DD CLASS="dd-description"> Mit <I><FONT COLOR=maroon>end-to-end security</FONT></I> bezeichnet
 man ein Modell, das gew�hrleistet, dass die �ber ein Netzwerk
 gesendeten Daten &ndash; w�hrend ihres Transports durch diese Netze &ndash;
 gesch�tzt werden. Um dies zu gew�hrleisten ist ein Verschl�sselungs-
 oder ein �quivalenter anderer Schutzmechanismus notwendig. Aufgrund
 des breiten Spektrums verf�gbarer Endger�te kann allerdings keine
 einheitliche L�sung des Problems geschaffen werden. Die
 Spezifikation deklariert die <I><FONT COLOR=maroon>end-to-end security</FONT></I>
 diesbez�glich als implementierungsabh�ngig (Vgl.&nbsp;: [<A HREF="#sm:jsr139"><CITE>T+03</CITE></A><CITE>, S. 32</CITE>]).
</DL>
<!--TOC section Mobile Information Device Profile (MIDP)-->

<H2 CLASS="section"><A NAME="htoc23">2.4</A>&nbsp;&nbsp;Mobile Information Device Profile (MIDP)</H2><!--SEC END -->

<A NAME="tgl:midp"></A>
<A NAME="@default57"></A>
<A NAME="@default58"></A><BR>
<BR>
<DIV style="float: left; margin: 0ex 1.5ex 0ex 0ex;"><IMG SRC="ObexObjectPassing011.gif"></DIV> Das <I><FONT COLOR=maroon>Mobile
 Information Device Profile (MIDP)</FONT></I> spezifiziert ein Profil, welches
auf die F�higkeiten eines kleinen mobilen Endger�ts &ndash; einem sogenannten
<I><FONT COLOR=maroon>Mobile Information Device (MID)</FONT></I> &ndash; abgestimmt ist. Das MIDP 2.0 ist das
Ergebnis des JSR-118, basiert auf dem MIDP 1.0 (JSR-37) und ist zu
diesem abw�rtskompatibel, sodass MIDlets<SUP><A NAME="text18" HREF="#note18">18</A></SUP>, die f�r das MIDP 1.0
geschrieben wurden, ebenfalls auf dem MIDP 2.0 lauff�hig
sind<SUP><A NAME="text19" HREF="#note19">19</A></SUP>. Das
MIDP spezifiziert eine auf der CLDC<SUP><A NAME="text20" HREF="#note20">20</A></SUP>
aufgesetzte Schicht. MIDP 2.0 setzt mindestens die Version 1.0 der
CLDC voraus, jedoch wird angenommen, dass die meisten MIDP 2.0
Implementierungen auf der CLDC 1.1 aufsetzen werden. Da MIDs
typischerweise eine sehr breite Spanne an Ressourcen zur Verf�gung
stellen, ist die Anzahl der Programmierschnittstellen auf das
Wesentliche reduziert worden, um eine m�glichst hohe Portabilit�t zu
gew�hrleisten. Aus diesem Grund sind einige Funktionsbereiche
abgegrenzt worden. Die abgegrenzten Bereiche sind die systemnahen
Programmierschnittstellen <I><FONT COLOR=maroon>(System-level APIs)</FONT></I> sowie die
Sicherheit der virtuellen Maschine <I><FONT COLOR=maroon>(Low-level security)</FONT></I> (Vgl.&nbsp;: [<A HREF="#sm:jsr118"><CITE>VW02</CITE></A><CITE>, S. 5f</CITE>]).<BR>
<BR>
Die spezifizierten Mindestanforderungen an das MID sind als
zus�tzliche Anforderungen zur CLDC zu betrachten. Die Anforderungen
sind unterteilt in Hard- und Softwareanforderungen. Die f�r die
vorliegende Arbeit relevanten Spezifikationspunkte sind das Netzwerk
sowie der spezifizierte Persistenzmechanismus:
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description">
<B>Netzwerk</B><DD CLASS="dd-description"> Die Netzwerkhardware muss eine
 Zwei-Wege-Funkverbindung (mit limitierter Bandbreite) zur Verf�gung
 stellen. Um das Netzwerk API zu unterst�tzen, muss der Software
 lesender und schreibender Zugriff auf die Funkverbindung gew�hrt
 werden.
<DT CLASS="dt-description"><B>Persistenzmechanismus</B><DD CLASS="dd-description"> Ein Mechanismus, um auf den
 nichtfl�chtigen Speicher zu schreiben und von ihm zu lesen, um die
 Anforderungen des <I><FONT COLOR=maroon>Record Management Systems</FONT></I><SUP><A NAME="text21" HREF="#note21">21</A></SUP> abzudecken.
</DL>
In der Spezifikation sind weitere Anforderungen an des Ger�t
definiert, die weitere Punkte wie Anzeige, Eingabemechanismen,
Speicheranforderungen und Audioeigenschaften festlegen. Es wird
weiterhin festgelegt, wie die Software-Landschaft des Ger�ts
auszusehen hat. Dies umfasst z.&nbsp;B. einen minimalistischen Kernel sowie
einen Mechanismus, der den Lebenszyklus der Applikation auf dem Ger�t
verwaltet (Vgl.&nbsp;: [<A HREF="#sm:jsr118"><CITE>VW02</CITE></A><CITE>, S. 7ff</CITE>]).<BR>
<BR>
<!--TOC subsection Record Management System (RMS)-->

<H3 CLASS="subsection"><A NAME="htoc24">2.4.1</A>&nbsp;&nbsp;Record Management System (RMS)</H3><!--SEC END -->

<A NAME="tgl:midp:rms"></A>
<A NAME="@default59"></A>
<A NAME="@default60"></A>
<A NAME="@default61"></A>
<A NAME="@default62"></A>
<A NAME="@default63"></A>
Das <I><FONT COLOR=maroon>Record Management System (RMS)</FONT></I> ist ein Mechanismus, der es
MIDlets erm�glicht, Daten persistent auf dem Ger�t abzulegen. Der
Mechanismus ist wie eine einfache datensatzorientierte Datenbank
modelliert (Vgl.&nbsp;: [<A HREF="#sm:jsr118"><CITE>VW02</CITE></A><CITE>, S. 463</CITE>]). <BR>
<BR>
<!--TOC subsubsection Record Store-->

<H4 CLASS="subsubsection"><A NAME="htoc25">2.4.1.1</A>&nbsp;&nbsp;Record Store</H4><!--SEC END -->

<A NAME="tgl:midp:rms:rs"></A>
<A NAME="@default64"></A>
<A NAME="@default65"></A>
<A NAME="@default66"></A>
Ein <I><FONT COLOR=maroon>Record Store</FONT></I> ist eine Ansammlung an Datens�tzen, die, �ber
mehrere Aufrufe der Applikation hinweg, persistent erhalten
bleiben. Die zu Grunde liegende Plattform ist f�r die Integrit�t der
Datens�tze verantwortlich. Sie ist auch f�r das Erzeugen des
<I><FONT COLOR=maroon>Record Stores</FONT></I> verantwortlich, der an einem der Plattform
spezifischen Ort liegt. Dieser Speicherort darf dem MIDlet, aus
Sicherheitsgr�nden, nicht bekanntgegeben werden. Der Name des
<I><FONT COLOR=maroon>Records Stores</FONT></I> wird allerdings auf Ebene des MIDlets
festgelegt. Dieser Name muss innerhalb eines MIDlets eindeutig
sein. Das RMS-API definiert keinen
Locking-Mechanismus. Schreiboperationen auf das Datenbanksystem werden
automatisch synchronisiert, was bedeutet, dass das API
<I><FONT COLOR=maroon>Thread-Safe</FONT></I><SUP><A NAME="text22" HREF="#note22">22</A></SUP> ist (Vgl.&nbsp;: [<A HREF="#sm:jsr118"><CITE>VW02</CITE></A><CITE>, S. 463f</CITE>]).<BR>
<BR>
<!--TOC subsubsection Records-->

<H4 CLASS="subsubsection"><A NAME="htoc26">2.4.1.2</A>&nbsp;&nbsp;Records</H4><!--SEC END -->

<A NAME="tgl:midp:rms:records"></A>
<A NAME="@default67"></A>
<A NAME="@default68"></A>
<A NAME="@default69"></A>
<I><FONT COLOR=maroon>Records</FONT></I> sind als Byte-Arrays implementiert. Der Entwickler kann
also <TT>DataInputStream</TT> und <TT>DataOutputStream</TT> sowie
<TT>ByteArrayInputStream</TT> und <TT>ByteArrayOutputStream</TT>
verwenden, um Daten in einen Datensatz zu schreiben bzw. von ihm zu
lesen. Jeder <I><FONT COLOR=maroon>Record</FONT></I> kann innerhalb eines <I><FONT COLOR=maroon>Record Stores</FONT></I>
anhand seiner eindeutigen Identifikationsnummer
(ID) zugeordnet werden. Das
bedeutet; wird ein Datensatz eingef�gt, erh�lt er die ID &#8222;n&#8220;. Der
n�chste eingef�gte Datensatz erh�lt die ID &#8222;n+1&#8220; (Vgl.&nbsp;: [<A HREF="#sm:jsr118"><CITE>VW02</CITE></A><CITE>, S.
464</CITE>]).<BR>
<BR>
Dieses Konzept der Enumeration wird konsequent verfolgt. Wird z.&nbsp;B. ein Datensatz gel�scht, wird die ID nicht wiederverwendet. Das
bedeutet; sind drei Datens�tze mit den IDs &gt;&gt;1&lt;&lt;, &gt;&gt;2&lt;&lt; und &gt;&gt;3&lt;&lt;
eingef�gt worden und wird der Datensatz mit der ID &gt;&gt;2&lt;&lt; gel�scht,
erh�lt der n�chste eingef�gte Datensatz die ID &gt;&gt;4&lt;&lt; und nicht wie
evtl. angenommen werden k�nnte, die ID &gt;&gt;2&lt;&lt;.

<!--TOC subsection MIDP Sicherheit-->

<H3 CLASS="subsection"><A NAME="htoc27">2.4.2</A>&nbsp;&nbsp;MIDP Sicherheit</H3><!--SEC END -->

<A NAME="tgl:midp:sec"></A>
<A NAME="@default70"></A>
<A NAME="@default71"></A>
Da sich das MIDP auf die Bereitstellung eines APIs f�r die
Applikationsentwicklung bezieht, wurden die <I><FONT COLOR=maroon>System-level</FONT></I> APIs
nicht weiter spezifiziert. Das heisst sie unterliegen der korrekten
Implementierung und den Sicherheitsanforderungen des Herstellers. Es
werden seitens der Spezifikation explizit keine weiteren
<I><FONT COLOR=maroon>Low-level</FONT></I> Sicherheitsmechanismen definiert (Vgl.&nbsp;: [<A HREF="#sm:jsr118"><CITE>VW02</CITE></A><CITE>, S. 6</CITE>]).<BR>
<BR>
Da das MIDP jedoch auf der CLDC aufsetzt, erbt es die bereits in der
CLDC vorhandenen Sicherheitsmechanismen. Das <I><FONT COLOR=maroon>System-level</FONT></I> API
wird prinzipiell von der <I><FONT COLOR=maroon>Application-level security</FONT></I>, die
<I><FONT COLOR=maroon>Low-level</FONT></I> Sicherheit von der gleichnamigen Sicherheit in der
CLDC abgedeckt<SUP><A NAME="text23" HREF="#note23">23</A></SUP>.<BR>
<BR>
Das MIDP 1.0 zwingt jedes MIDlet dazu, innerhalb einer Sandbox
ausgef�hrt zu werden, die jeglichen Zugriff auf sensitive
Schnittstellen oder Funktionen des Ger�ts unterbindet. Dieses Konzept
wird vom MIDP 2.0 ebenfalls f�r jedes nicht vertrauensw�rdige
<I><FONT COLOR=maroon>(untrusted)</FONT></I> MIDlet verlangt. Jede MIDP 2.0 Implementierung ist
verpflichtet, Unterst�tzung f�r <I><FONT COLOR=maroon>untrusted</FONT></I> MIDlets
anzubieten. Mit dem MIDP 2.0 ist das Konzept vertrauter
<I><FONT COLOR=maroon>(trusted)</FONT></I> Applikationen eingef�hrt worden, das den Zugriff auf
sensitive Schnittstellen erlaubt. Nicht vertrauensw�rdige MIDlets
m�ssen innerhalb der vom MIDP 1.0 spezifizierten Sandbox
ausgef�hrt werden. Findet beim Ausf�hren eines solchen MIDlets ein
Zugriff auf nicht vertrauensw�rdige Schnittstellen statt, muss der
Zugriff entweder verworfen, oder, nach einer explizit angeforderten
Genehmigung des Benutzers, erlaubt werden. Das <I><FONT COLOR=maroon>trusted</FONT></I> Modell
definiert im Gegensatz dazu drei verschiedene Interaktionsmuster, die
als <I><FONT COLOR=maroon>User Permission Modes</FONT></I> bezeichnet werden. Sie erm�glichen es
dem Benutzer, den Zugriff auf ein bestimmtes API zu erlauben oder zu
verwehren (Vgl.&nbsp;: [<A HREF="#sm:jsr118"><CITE>VW02</CITE></A><CITE>, S. 23ff</CITE>]).<BR>
<BR>
Die verschiedenen Zugriffsmodi, die vom Benutzer festgelegt werden
k�nnen, sowie deren G�ltigkeitszeitraum sind in
[Tab.: <A HREF="#tgl:midp:sec:gzr">2.5</A>] festgehalten.
<BLOCKQUOTE CLASS="table"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
 <A NAME="@default72"></A>
 <TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">User Permission</SPAN></TD>
<TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">G�ltigkeitszeitraum</SPAN></TD>
</TR>
<TR><TD VALIGN=top ALIGN=left><I><FONT COLOR=maroon>blanket</FONT></I></TD>
<TD VALIGN=top ALIGN=left>G�ltig f�r jede Ausf�hrung der MIDlet-Applikation bis
 sie deinstalliert oder die Rechte vom Benutzer ge�ndert werden.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left><I><FONT COLOR=maroon>session</FONT></I></TD>
<TD VALIGN=top ALIGN=left>G�ltig vom Start eines MIDlets, bis zu dessen
 Termination. Der &#8220;session&#8221; Modus ist verpflichtet, den Benutzer
 beim oder vor dem ersten Aufruf einer gesch�tzten Funktion einen
 Dialog anzuzeigen, in dem der Benutzer entweder den Zugriff
 gestattet oder ablehnt. Bei einem erneuten Start des MIDlets muss
 diese Abfrage erneut erfolgen.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left><I><FONT COLOR=maroon>oneshot</FONT></I></TD>
<TD VALIGN=top ALIGN=left>Eine Interaktion mit dem Benutzer ist bei jedem
 Zugriff auf ein gesch�tztes API notwendig.</TD>
</TR></TABLE>
 <DIV CLASS="center">Tabelle 2.5: G�ltigkeitszeitraum der Rechte eines MIDlets (Vgl.&nbsp;: [<A HREF="#sm:jsr118"><CITE>VW02</CITE></A><CITE>, S. 26</CITE>])</DIV>
<A NAME="tgl:midp:sec:gzr"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
 

<!--TOC section Java API for Bluetooth (JSR-82)-->

<H2 CLASS="section"><A NAME="htoc28">2.5</A>&nbsp;&nbsp;Java API for Bluetooth (JSR-82)</H2><!--SEC END -->

<A NAME="tgl:jbt"></A>
<A NAME="@default73"></A>
<A NAME="@default74"></A>
Um die Bluetooth Funktionalit�t von einem MIDlet aus ansprechen zu
k�nnen, ist ein entsprechendes API notwendig. Der
JSR-82<SUP><A NAME="text24" HREF="#note24">24</A></SUP>
definiert ein solches API sowie dessen Architektur, um
Drittherstellern die M�glichkeit zu geben, Programme zu entwickeln, die
eine Bluetooth Funkverbindung zur gegenseitigen Kommunikation nutzen.
Das mit dem JSR-82 entwickelte API, das auch unter dem Akronym
JABWT
<I><FONT COLOR=maroon>(Java API for Bluetooth Wireless Technology)</FONT></I> bekannt ist, baut
auf der Grundlage der CLDC [Kapitel <A HREF="#tgl:cldc">2.3</A>] auf und basiert auf der
Bluetooth Spezifikation in der Version 1.1<SUP><A NAME="text25" HREF="#note25">25</A></SUP>. Es
ist als optionale Erweiterung eines MIDP [Kapitel <A HREF="#tgl:midp">2.4</A>] zu sehen
(Vgl.&nbsp;: [<A HREF="#sm:jsr82"><CITE>M+05</CITE></A><CITE>, S. 11</CITE>]).<BR>
<BR>
Mit der Spezifikation wurde beabsichtigt, eine Grundlage zu schaffen,
mit der es erm�glicht wird, weitere Profile zu entwickeln. Dazu werden
APIs f�r das L2CAP und OBEX<SUP><A NAME="text26" HREF="#note26">26</A></SUP> Protokoll angeboten, auf deren Basis
zuk�nftige Profile entwickelt werden k�nnen. Das API bietet folgende
Dienste an:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Registrierung eines Dienstes
<LI CLASS="li-enumerate">Ger�t- und Dienstsuche
<LI CLASS="li-enumerate">M�glichkeit, L2CAP und OBEX Verbindungen herzustellen.
<LI CLASS="li-enumerate">Sichere Ausf�hrung dieser Aktivit�ten.
</OL>
Da nicht alle Profile und Ebenen der Bluetooth Spezifikation
�bernommen werden k�nnen, beschr�nkt sich der Umfang des APIs
lediglich auf Datendienste. Sprachdienste k�nnen nicht verarbeitet
bzw. angesteuert werden (Vgl.&nbsp;: [<A HREF="#sm:jsr82"><CITE>M+05</CITE></A><CITE>, S. 14</CITE>]).<BR>
<BR>
<!--TOC subsection Anforderungen-->

<H3 CLASS="subsection"><A NAME="htoc29">2.5.1</A>&nbsp;&nbsp;Anforderungen</H3><!--SEC END -->

<A NAME="tgl:jbt:anf"></A> 
<A NAME="@default75"></A>
<A NAME="@default76"></A>
Die vom JSR-82 definierten Anforderungen sind als Zus�tze zu den
bereits bestehenden Anforderungen der CLDC zu betrachten. Sie umfassen
Anforderungen an die Spezifikation selbst, wie z.&nbsp;B. eine alleinige
Abh�ngigkeit zu den CLDC Bibliotheken. Auf die
Spezifikationsanforderungen soll jedoch nicht n�her eingegangen
werden. Es sind vielmehr die Anforderungen an das Ger�t sowie die des zu
Grunde liegenden Bluetooth-Systems von Interesse.
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description">
<B>Hardware-Anforderungen</B><DD CLASS="dd-description"> Das JSR-82 API ist entwickelt worden, um
 auf Ger�te mit folgenden Hardware-Charakteristika eingesetzt werden
 zu k�nnen.
 <UL CLASS="itemize"><LI CLASS="li-itemize">
 <A NAME="tgl:jbt:anf:hw"></A>
 Mindestens 512 Kilobyte Speicher f�r die Java Plattform
 (ROM/Flash und
 RAM). Der f�r die
 Applikationen notwendige Speicher ist im Speicherkontingent nicht
 enthalten und muss additiv bereitgestellt werden.
 <LI CLASS="li-itemize">Bluetooth Kommunikations-Hardware, mit zugeh�rigem Stack und
 Funkmodul.
 <LI CLASS="li-itemize">Implementierung der J2ME CLDC APIs oder einem Superset derer,
 wie z.&nbsp;B. der CDC.
 </UL>
<DT CLASS="dt-description"><B>Bluetooth-Anforderungen</B><DD CLASS="dd-description"> Die Anforderungen an das zu Grunde
 liegende Bluetooth-System sind folgende:
 <UL CLASS="itemize"><LI CLASS="li-itemize">
 Das System muss das <I><FONT COLOR=maroon>Bluetooth Qualification Program</FONT></I> f�r
 mindestens das <I><FONT COLOR=maroon>Generic Access Profile</FONT></I>, das <I><FONT COLOR=maroon>Service
 Discovery Application Profile</FONT></I> und das <I><FONT COLOR=maroon>Serial Port
 Profile</FONT></I> durchlaufen haben.
 <LI CLASS="li-itemize">Die folgenden Schichten m�ssen, wie in der Bluetooth
 Spezifikation (Version 1.1) unterst�tzt werden und die
 Implementierung muss Zugriff auf diese haben.
 <UL CLASS="itemize"><LI CLASS="li-itemize">
 <I><FONT COLOR=maroon>Service Discovery Protocol
 (SDP)</FONT></I>
 <LI CLASS="li-itemize">RFCOMM<SUP><A NAME="text27" HREF="#note27">27</A></SUP> (Typ 1
 Unterst�tzung)
 <LI CLASS="li-itemize"><I><FONT COLOR=maroon>Logical Link Control and Adaption Protocol (L2CAP)</FONT></I>
 </UL>
 <LI CLASS="li-itemize">Eine vom System bereitgestellte Entit�t, das <I><FONT COLOR=maroon>Bluetooth
 Control Center (BCC)</FONT></I>, welches es einem Benutzer oder
 <I><FONT COLOR=maroon>Original Equipment Manufacturer
 (OEM)</FONT></I>
 erlaubt, spezifische Bluetooth-Parameter zu konfigurieren.
 </UL>
</DL>
<A NAME="tgl:jbt:anf:obeximpl"></A>
Die Unterst�tzung f�r das <I><FONT COLOR=maroon>OBject EXchange
 (OBEX)</FONT></I> Protokoll kann
entweder bereits vom zu Grunde liegenden Bluetooth-System, oder durch
Implementierung des JSR-82 APIs bereitgestellt werden [<A HREF="#sm:jsr82"><CITE>M+05</CITE></A><CITE>, S.
14f</CITE>].<BR>
<BR>
<!--TOC subsection Paketierung-->

<H3 CLASS="subsection"><A NAME="htoc30">2.5.2</A>&nbsp;&nbsp;Paketierung</H3><!--SEC END -->

<A NAME="tgl:jbt:pkg"></A>
<A NAME="@default77"></A>
In der Spezifikation sind zwei Pakete definiert:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>javax.bluetooth</TT>
<LI CLASS="li-itemize"><TT>javax.obex</TT>
</UL>
Auf Grund der Tatsache, dass das OBEX API unabh�ngig ist von Bluetooth,
wird es in einem separaten Paket ausgeliefert. Eine CLDC ist somit in
der Lage, entweder nur eines der beiden, oder beide auszuliefern. Das
Paket <TT>javax.bluetooth</TT> beinhaltet die Bluetooth
Basisbibliotheken, wohingegen das <TT>javax.obex</TT> Paket die
Implementierung des OBEX APIs beinhaltet. Aus diesem Grund werden auch
zwei verschiedene <I><FONT COLOR=maroon>Technology Compatibility Kits
 (TCK)</FONT></I> zur Verf�gung gestellt, mit Hilfe derer die Implementierung
 gegen�ber der Spezifikation getestet werden kann [<A HREF="#sm:jsr82"><CITE>M+05</CITE></A><CITE>, S. 21</CITE>].<BR>
<BR>
<!--TOC subsection Bluetooth Control Center-->

<H3 CLASS="subsection"><A NAME="htoc31">2.5.3</A>&nbsp;&nbsp;Bluetooth Control Center</H3><!--SEC END -->

<A NAME="tgl:jbt:bcc"></A>
Bei Ger�ten die das JSR-82 API implementieren, kann es u.&nbsp;U. m�glich
sein, dass mehrere Applikationen zeitgleich ausgef�hrt werden. Die
Notwendigkeit eines <I><FONT COLOR=maroon>Bluetooth Control Centers
 (BCC)</FONT></I> ergibt sich aus dem Wunsch, zu verhindern, dass eine
Applikation eine andere nachteilig beeinflusst. Es ist als zentrale
Anlaufstelle des lokalen Bluetooth-Ger�ts zu sehen. Die
Implementierung des BCC kann entweder als native Applikation bzw. als
Applikation mit separatem API oder als fixe Gruppe von Eigenschaften,
die nicht vom Benutzer ge�ndert werden k�nnen, umgesetzt werden. Das
BCC ist nicht als Klasse oder Schnittstelle innerhalb des JSR-82 APIs
spezifiziert, stellt jedoch eine wichtige Rolle f�r die
Sicherheitsarchitektur des JSR-82 dar. Das BCC muss der JSR-82
Implementierung folgende Funktionen zur Verf�gung stellen:
<UL CLASS="itemize"><LI CLASS="li-itemize">
Basissicherheitseinstellungen des Ger�ts, inklusive der in der
 Bluetooth-Spezifikation definierten Sicherheitsmodi.
<LI CLASS="li-itemize">Liste der dem Ger�t bereits bekannten Bluetooth-Ger�te, die sich
 nicht zwingend in Reichweite befinden m�ssen.
<LI CLASS="li-itemize">Liste der vom Ger�t bereits als vertrauensw�rdig eingestuften
 Bluetooth-Ger�te, die sich nicht zwingend in Reichweite befinden
 m�ssen.
</UL>
Keine dieser Informationen darf von einer Applikation aus ge�ndert
werden k�nnen. Die einzige Applikation, die berechtigt ist dies zu
tun, ist das BCC. Das BCC kann weitere Eigenschaften des Ger�ts
zug�nglich machen, wie z.&nbsp;B. die Einstellung des Ger�tenamens
<I><FONT COLOR=maroon>(friendly name)</FONT></I> oder die M�glichkeit, das Ger�t auf die
Werkseinstellungen zur�ckzusetzen [<A HREF="#sm:jsr82"><CITE>M+05</CITE></A><CITE>, S. 22</CITE>].<BR>
<BR>

<!--TOC subsection Eigenschaften des Ger�ts-->

<H3 CLASS="subsection"><A NAME="htoc32">2.5.4</A>&nbsp;&nbsp;Eigenschaften des Ger�ts</H3><!--SEC END -->

<A NAME="tgl:jbt:dp"></A>
<A NAME="@default78"></A>
<A NAME="@default79"></A> <A NAME="@default80"></A> Da sich je nach Einsatzzweck
die Konfiguration der Bluetooth-Ger�te unterscheidet, besteht die
Notwendigkeit, bestimmte Eigenschaften des Ger�ts abzufragen. Das API
definiert eine Reihe von Eigenschaften, die durch einen Aufruf der
Funktion <TT>LocalDevice.getProperty()</TT> abgefragt werden k�nnen.
Die Werte, die abgefragt werden k�nnen, sind in
[Tab.: <A HREF="#tgl:jbt:dp:dpt">2.6</A>] dargestellt. Soll ein solcher Wert
abgefragt werden, ist zu beachten, dass die Zeichenketten <I><FONT COLOR=maroon>case
 sensitive</FONT></I><SUP><A NAME="text28" HREF="#note28">28</A></SUP> sind.
Ist die Eigenschaft nicht definiert, oder unbekannt, muss <TT>null</TT>
zur�ckgegeben werden. S�mtliche Eigenschaften, die durch
<TT>LocalDevice.getProperty()</TT> abgefragt werden k�nnen, m�ssen
ebenfalls durch die von der CLDC bereitgestellte Funktion
<TT>System.getProperty()</TT> zug�nglich sein [<A HREF="#sm:jsr82"><CITE>M+05</CITE></A><CITE>, S. 23f</CITE>].
<BLOCKQUOTE CLASS="table"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
 <TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">Eigenschaft</SPAN></TD>
<TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">Beschreibung</SPAN></TD>
</TR>
<TR><TD VALIGN=top ALIGN=left>bluetooth.api.version obex.api.version</TD>
<TD VALIGN=top ALIGN=left>Version des <I><FONT COLOR=maroon>Java APIs for Bluetooth
 wireless technology</FONT></I> die unterst�tzt wird. F�r die Version 1.1
 wird entsprechend &#8220;1.1&#8221; zur�ckgeliefert.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left>bluetooth.l2cap.receiveMTU.max</TD>
<TD VALIGN=top ALIGN=left><I><FONT COLOR=maroon>Maximum Transfer Unit</FONT></I> (MTU) in Empfangsrichtung, die
 von L2CAP unterst�tzt wird. Der zur�ckgelieferte Wert ist dezimal
 in einem <TT>java.lang.String</TT> kodiert.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left> bluetooth.connected.devices.max</TD>
<TD VALIGN=top ALIGN=left>Maximale Anzahl verbundener Ger�te.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left> bluetooth.connected.inquiry</TD>
<TD VALIGN=top ALIGN=left>Kann eine Ger�tesuche durchgef�hrt
 werden, w�hrend das Ger�t bereits verbunden ist?</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left>bluetooth.connected.page</TD>
<TD VALIGN=top ALIGN=left>Kann das lokale Ger�t eine Verbindung
 zu einem entfernten Ger�t herstellen, wenn das lokale Ger�t bereits
 verbunden ist?</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left> bluetooth.connected.inquiry.scan</TD>
<TD VALIGN=top ALIGN=left>Kann das lokale Ger�t auf eine
 Suchanfrage antworten, w�hrend es mit einem anderen Ger�t verbunden
 ist?</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left> bluetooth.connected.page.scan</TD>
<TD VALIGN=top ALIGN=left>Kann das lokale Ger�t eine
 Verbindung von einem anderen Ger�t annehmen, w�hrend es bereits mit
 einem anderen Ger�t verbunden ist?</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left> bluetooth.master.switch</TD>
<TD VALIGN=top ALIGN=left>Ist der <I><FONT COLOR=maroon>master/slave</FONT></I> Wechsel erlaubt?</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left> bluetooth.sd.trans.max</TD>
<TD VALIGN=top ALIGN=left>Maximale Anzahl zeitgleicher Dienstsuchen
 <I><FONT COLOR=maroon>(Service Discovery)</FONT></I></TD>
</TR>
<TR><TD VALIGN=top ALIGN=left> bluetooth.sd.attr.retrievable.max</TD>
<TD VALIGN=top ALIGN=left>Maximale Anzahl der
 <I><FONT COLOR=maroon>Service</FONT></I>-Attribute die mit einem <I><FONT COLOR=maroon>Service Record</FONT></I>
 empfangen werden k�nnen.</TD>
</TR></TABLE>
 <DIV CLASS="center">Tabelle 2.6: �bersicht der
 Eigenschaften des Ger�ts (Vgl. [<A HREF="#sm:jsr82"><CITE>M+05</CITE></A><CITE>, S. 24, Tabelle
 3-2 Device Properties</CITE>])</DIV>
<A NAME="tgl:jbt:dp:dpt"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
<!--TOC subsection Client-/Server Modell-->

<H3 CLASS="subsection"><A NAME="htoc33">2.5.5</A>&nbsp;&nbsp;Client-/Server Modell</H3><!--SEC END -->

<A NAME="tgl:jbt:cs"></A>
<A NAME="@default81"></A>
Ein Bluetooth-Dienst (Service) ist eine Server-Applikation, die einem
Client eine bestimmte Funktionalit�t erm�glicht. Ein Service zum
Drucken �ber Bluetooth w�re bspw. eine solche Applikation. Entwickler,
die mit Bluetooth arbeiten, k�nnen ihre eigenen Server-Applikationen
schreiben, die sie anderen (Clients) zur Verf�gung stellen. 
Dies wird realisiert, indem der <I><FONT COLOR=maroon>Service Discovery Database
 (SDDB)</FONT></I> des lokalen
Bluetooth-Ger�ts ein sogenannter <I><FONT COLOR=maroon>Service Record</FONT></I> hinzugef�gt
wird, der den angebotenen Dienst beschreibt. Nachdem der Service
registriert wurde, wartet der Server auf einen Client, der die
Verbindung zu dem gew�nschten Service initiiert [<A HREF="#sm:jsr82"><CITE>M+05</CITE></A><CITE>, S.
24</CITE>].<BR>
<BR>
<!--TOC subsection Discovery-->

<H3 CLASS="subsection"><A NAME="htoc34">2.5.6</A>&nbsp;&nbsp;Discovery</H3><!--SEC END -->

<A NAME="tgl:jbt:disc"></A>
<A NAME="@default82"></A>
Da die meisten mit Bluetooth ausgestatteten Ger�te tragbar sind, wird
ein Mechanismus ben�tigt, der es erm�glicht, dass sich zwei oder
mehr Ger�te finden k�nnen. Dieser Prozess wird als
<I><FONT COLOR=maroon>Discovery</FONT></I> bezeichnet. Es existieren hierbei zwei
Discovery-Arten; Device- und Service-Discovery [<A HREF="#sm:jsr82"><CITE>M+05</CITE></A><CITE>, S. 27</CITE>].<BR>
<BR>
<!--TOC subsubsection Device Discovery-->

<H4 CLASS="subsubsection"><A NAME="htoc35">2.5.6.1</A>&nbsp;&nbsp;Device Discovery</H4><!--SEC END -->

<A NAME="tgl:jbt:disc:dd"></A>
<A NAME="@default83"></A> <A NAME="@default84"></A>
<A NAME="@default85"></A> Ger�te k�nnen von einer Applikation mit
Hilfe der Funktion <TT>startInquiry()</TT>, die nicht blockierend
implementiert ist, oder mit ihrem blockierenden �quivalent
<TT>retrieveDevices()</TT> gefunden werden. Die
<TT>retrieveDevices()</TT> Methode ist jedoch nicht in der Lage,
&#8220;neue&#8221; Ger�te zu finden, sondern liefert lediglich eine Liste der
dem Ger�t bereits bekannten Ger�te. Das sind Ger�te, die bspw. in einer
vorhergehenden Suche bereits gefunden wurden oder Ger�te die als
<I><FONT COLOR=maroon>Pre-known</FONT></I> klassifiziert sind. Als <I><FONT COLOR=maroon>Pre-known</FONT></I> Ger�te
bezeichnet man Ger�te, die im BCC definiert wurden. Die
<TT>retrieveDevices()</TT> Methode f�hrt keine aktive Suche durch,
stellt aber die M�glichkeit dar, eine Liste von Ger�ten zu erhalten,
die sich im n�heren Umfeld befinden k�nnten. Wird die
<TT>startInquiry()</TT> Methode verwendet, muss zus�tzlich ein Listener
implementiert werden, der benachrichtigt wird sobald ein neues Ger�t
gefunden wurde. Der zu implementierende Listener ist im Interface
<TT>javax.bluetooth.DiscoveryListener</TT> definiert. Die Klasse
<TT>javax.bluetooth.DiscoveryAgent</TT> bietet die entsprechenden
Methoden zur Ger�te- und Dienstsuche an [<A HREF="#sm:jsr82"><CITE>M+05</CITE></A><CITE>, S. 28f</CITE>].<BR>
<BR>
<!--TOC subsubsection Service Discovery-->

<H4 CLASS="subsubsection"><A NAME="htoc36">2.5.6.2</A>&nbsp;&nbsp;Service Discovery</H4><!--SEC END -->

<A NAME="tgl:jbt:disc:sd"></A>
<A NAME="@default86"></A>
Nachdem ein Ger�t mittels einer <I><FONT COLOR=maroon>Device Discovery</FONT></I>
ausfindig gemacht werden konnte, ist es i.&nbsp;d.&nbsp;R. von Interesse
herauszufinden, ob auf dem gefundenen Ger�t der gew�nschte Dienst
vorhanden ist. Die Suche nach einem solchen Dienst wird als
<I><FONT COLOR=maroon>Service Discovery</FONT></I> bezeichnet. Eine lokale Service-Suche wird
vom JSR-82 API allerdings nicht unterst�tzt. Die in eine Service-Suche
involvierten Klassen sind Folgende [<A HREF="#sm:jsr82"><CITE>M+05</CITE></A><CITE>, S. 30f</CITE>]:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>javax.bluetooth.UUID</TT>
<LI CLASS="li-itemize"><TT>javax.bluetooth.DataElement</TT>
<LI CLASS="li-itemize"><TT>javax.bluetooth.ServiceRecord</TT>
<LI CLASS="li-itemize"><TT>javax.bluetooth.DiscoveryAgent</TT>
<LI CLASS="li-itemize"><TT>javax.bluetooth.DiscoveryListener</TT>
</UL>
In der Spezifikation ist zu jeder der aufgelisteten Klassen
Beispielcode zu finden, der die Anwendung der Klassen verdeutlicht.<BR>
<BR>
<!--TOC subsection Generic Access Profile (GAP)-->

<H3 CLASS="subsection"><A NAME="htoc37">2.5.7</A>&nbsp;&nbsp;Generic Access Profile (GAP)</H3><!--SEC END -->

<A NAME="tgl:jbt:gap"></A>
Im Kapitel 7 der JSR-82 Spezifikation sind die Klassen aufgef�hrt, die
dazu dienen, Eigenschaften des Ger�ts zu manipulieren, die Teil des
GAPs<SUP><A NAME="text29" HREF="#note29">29</A></SUP> sind. Die
Standardmechanismen zur Manipulation des lokalen Ger�ts befinden sich
in der Klasse <TT>javax.bluetooth.LocalDevice</TT>, die Methoden um
Informationen von einem entfernten Ger�t zu erhalten befinden sich in
der Klasse <TT>javax.bluetooth.RemoteDevice</TT>. Die Klasse
<TT>javax.bluetooth.DeviceClass</TT> definiert Werte, mit Hilfe derer
es m�glich ist den Ger�tetyp sowie den Typ des Angebotenen Dienstes
zu identifizieren [<A HREF="#sm:jsr82"><CITE>M+05</CITE></A><CITE>, S. 50f</CITE>].<BR>
<BR>
<!--TOC subsection Kommunikation-->

<H3 CLASS="subsection"><A NAME="htoc38">2.5.8</A>&nbsp;&nbsp;Kommunikation</H3><!--SEC END -->

<A NAME="tgl:jbt:comm"></A>
<A NAME="@default87"></A>
<A NAME="@default88"></A>
Um den Dienst eines anderen Bluetooth-Ger�ts in Anspruch nehmen zu
k�nnen, m�ssen beide Ger�te in der Lage sein miteinander zu
kommunizieren. Dies erfordert die Kenntnis eines gemeinsamen
Kommunikationsprotokolls, sodass verschiedene Applikationen
miteinander kommunizieren k�nnen. Der JSR-82 stellt APIs zur Verf�gung,
mit deren Hilfe man Verbindungen zu RFCOMM, L2CAP oder OBEX Diensten
herstellen kann. Das <I><FONT COLOR=maroon>Generic Connection Framework
 (GCF)</FONT></I><SUP><A NAME="text30" HREF="#note30">30</A></SUP> der CLDC stellt dabei
den Basismechanismus der Protokollimplementierung dar (Vgl.&nbsp;: [<A HREF="#sm:jsr82"><CITE>M+05</CITE></A><CITE>, S.
63</CITE>]).<BR>
<BR>
<!--TOC subsubsection Serial Port Profile-->

<H4 CLASS="subsubsection"><A NAME="htoc39">2.5.8.1</A>&nbsp;&nbsp;Serial Port Profile</H4><!--SEC END -->

<A NAME="tgl:jbt:comm:spp"></A>
<A NAME="@default89"></A>
<A NAME="@default90"></A>
<A NAME="@default91"></A>
Das RFCOMM Protokoll emuliert mehrere RS-232
Ports zwischen zwei Bluetooth Endger�ten. Die Bluetooth-Adressen der
beiden Endger�te identifizieren hierbei die RFCOMM Sitzung. Zwischen
zwei Ger�ten darf immer nur eine Sitzung bestehen, die jedoch �ber
mehr als eine Verbindung verf�gen darf. Die Anzahl gleichzeitiger
Verbindungen ist hierbei abh�ngig von der jeweiligen Implementierung.
Eine Applikation, die einen Dienst auf Basis des <I><FONT COLOR=maroon>Serial Port
 Profiles (SPP)</FONT></I> anbietet,
wird dabei als SPP Server, eine die zu einem solchen eine Verbindung
initiiert, als SPP Client bezeichnet. Nachdem eine Verbindung
hergestellt ist, k�nnen Daten in beiden Richtungen ausgetauscht werden.
Die Aushandlung der Verbindungsparameter sowie der Flusskontrolle muss
hierbei automatisch zwischen den an der Kommunikation teilnehmenden
Endger�ten von der SPP Implementierung gehandhabt werden (Vgl.&nbsp;: [<A HREF="#sm:jsr82"><CITE>M+05</CITE></A><CITE>, S.
64ff</CITE>]).<BR>
<BR>
Innerhalb eines Code-Fragments sind SPP Verbindungen (Client- oder
Serverseitig) am String <TT>"btspp://"</TT> innerhalb von
<A NAME="@default92"></A><TT>Connector.open()</TT> zu erkennen. Stellt
die Applikation einen Dienst zur Verf�gung, ist
<TT>"btspp://localhost"</TT> zu Beginn des Strings enthalten.<BR>
<BR>
URLs, die einen Verbindungsaufbau zu einem
entfernten Ger�t erm�glichen, sind nach folgendem Schema aufgebaut:<BR>
<BR>
<TT>{scheme}:[{target}{params}]</TT><BR>
<BR>
Um RFCOMM zu benutzen ist das Schema (<TT>{scheme}</TT>), das f�r
Client und Server verwendet wird, <TT>btspp</TT>. Die beiden anderen
Platzhalter (<TT>{target}</TT> und <TT>{params}</TT>) unterscheiden
sich, je nachdem, ob die Applikation einen Client oder Server
darstellt. Alle g�ltigen Parameter, die in einem RFCOMM, L2CAP oder
OBEX �ber RFCOMM Verbindungskennzeichner vorkommen k�nnen, sind in
[Tab.: <A HREF="#tgl:jbt:comm:spp:vp">2.7</A>] aufgelistet.<BR>
<BR>
<A NAME="@default93"></A>
<A NAME="@default94"></A>
<A NAME="@default95"></A>
<A NAME="@default96"></A>
<BLOCKQUOTE CLASS="table"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
 <TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">Name</SPAN></TD>
<TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">Beschreibung</SPAN></TD>
<TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">Zul�ssige Werte</SPAN></TD>
<TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">Client oder Server</SPAN></TD>
</TR>
<TR><TD VALIGN=top ALIGN=left>master</TD>
<TD VALIGN=top ALIGN=left>Gibt an, ob das Ger�t master der Verbindung sein muss.</TD>
<TD VALIGN=top ALIGN=left><TT>true</TT>, <TT>false</TT></TD>
<TD VALIGN=top ALIGN=left>Beide</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left>authenticate</TD>
<TD VALIGN=top ALIGN=left>Gibt an, ob das entfernte Ger�t authentifiziert
 werden muss bevor eine Verbindung hergestellt werden kann.</TD>
<TD VALIGN=top ALIGN=left><TT>true</TT>, <TT>false</TT></TD>
<TD VALIGN=top ALIGN=left>Beide</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left>encrypt</TD>
<TD VALIGN=top ALIGN=left>Gibt an, ob die Verbindung verschl�sselt werden muss.</TD>
<TD VALIGN=top ALIGN=left><TT>true</TT>, <TT>false</TT></TD>
<TD VALIGN=top ALIGN=left>Beide</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left>authorize</TD>
<TD VALIGN=top ALIGN=left>Gibt an, ob alle Verbindungen zu diesem Ger�t
 authorisiert werden m�ssen um den Dienst zu nutzen.</TD>
<TD VALIGN=top ALIGN=left><TT>true</TT>, <TT>false</TT></TD>
<TD VALIGN=top ALIGN=left>Server</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left>name</TD>
<TD VALIGN=top ALIGN=left>Der Name des angebotenen Dienstes, der in der SDDB
 gespeichert wird.</TD>
<TD VALIGN=top ALIGN=left>Jeder g�ltige String</TD>
<TD VALIGN=top ALIGN=left>Server</TD>
</TR></TABLE>
 <DIV CLASS="center">Tabelle 2.7: G�ltige Parameter f�r RFCOMM
 Verbindungskennzeichner (Vgl.&nbsp;: [<A HREF="#cbk:bap"><CITE>BJJ04</CITE></A><CITE>, S. 59, Tabelle
 4.1 Valid Parameters for RFCOMM Connection Strings</CITE>])</DIV>
<A NAME="tgl:jbt:comm:spp:vp"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
<!--TOC subsubsection Object Exchange Protocol (OBEX)-->

<H4 CLASS="subsubsection"><A NAME="htoc40">2.5.8.2</A>&nbsp;&nbsp;Object Exchange Protocol (OBEX)</H4><!--SEC END -->

<A NAME="tgl:jbt:comm:obex"></A>
<A NAME="@default97"></A>
<A NAME="@default98"></A>
Das OBEX Protokoll wurde urspr�nglich von der <I><FONT COLOR=maroon>Infrared Data
 Association (IrDA)</FONT></I><SUP><A NAME="text31" HREF="#note31">31</A></SUP>
entwickelt, um Objekte auf einen Client oder Server zu &#8220;schieben&#8221;
<I><FONT COLOR=maroon>(push)</FONT></I> oder sie von diesem zu &#8220;ziehen&#8221; <I><FONT COLOR=maroon>(pull)</FONT></I>. Um
Objekte zu transferieren, etabliert OBEX zun�chst eine Sitzung. Eine
OBEX Sitzung beginnt mit einer <SPAN STYLE="font-variant:small-caps">CONNECT</SPAN> Anforderung und endet
mit einer <SPAN STYLE="font-variant:small-caps">DISCONNECT</SPAN> Anforderung. W�hrend die Sitzung etabliert
ist, kann der Client Objekte vom Server holen <SPAN STYLE="font-variant:small-caps">(GET)</SPAN> oder
Objekte am Server ablegen <SPAN STYLE="font-variant:small-caps">(PUT)</SPAN>. Diese Objekte k�nnen Dateien,
Visitenkarten (vCards<SUP><A NAME="text32" HREF="#note32">32</A></SUP>) oder Byte-Arrays darstellen. Indem der Client das
<SPAN STYLE="font-variant:small-caps">SETPATH</SPAN> Kommando sendet, kann er den Server dazu veranlassen,
sein aktuelles Verzeichnis zu wechseln (Vgl.&nbsp;: [<A HREF="#sm:jsr82"><CITE>M+05</CITE></A><CITE>, S. 93</CITE>]).<BR>
<BR>
OBEX skaliert sehr gut, egal ob es sich um grosse oder kleine Dateien
handelt die �bertragen werden m�ssen. Erreicht wird dies dadurch, dass
OBEX die zu �bertragenden Daten in mehreren Paketen schickt. Sobald
der Client eine <SPAN STYLE="font-variant:small-caps">PUT</SPAN> oder <SPAN STYLE="font-variant:small-caps">GET</SPAN> Anforderung sendet, wird
eine OBEX-Operation gestartet. Diese Operation besteht solange, bis
die Datei vollst�ndig �bertragen ist oder ein Fehler eintritt. Um
eine <SPAN STYLE="font-variant:small-caps">PUT</SPAN> Operation durchzuf�hren, bricht der Client
(Applikation oder Protokoll-Stack) das zu sendende Objekt in kleine
St�cke und sendet jedes einzeln an den Server. Der Client sendet das
nachfolgende St�ck nicht bevor der korrekte Versand des
Vorg�ngerst�cks best�tigt wurde (Vgl.&nbsp;: [<A HREF="#sm:jsr82"><CITE>M+05</CITE></A><CITE>, S. 93</CITE>]).<BR>
<BR>
<A NAME="@default99"></A> OBEX bietet, wie das <I><FONT COLOR=maroon>Hypertext Transfer
 Protocol (HTTP)</FONT></I><SUP><A NAME="text33" HREF="#note33">33</A></SUP>, die M�glichkeit,
zus�tzliche Informationen zwischen Client und Server auszutauschen.
Diese zus�tzlichen Meta-Informationen befinden sich im OBEX-Header,
der im vergleich zum HTTP-Header lediglich Byte-Werte
akzeptiert<SUP><A NAME="text34" HREF="#note34">34</A></SUP>. OBEX bietet Standard-Header an, wie z.&nbsp;B. Name-,
L�nge- und Beschreibungsfelder. Zus�tzlich existieren noch 64 Header
die vom Anwender definiert &ndash; und belegt &ndash; werden d�rfen (Vgl.&nbsp;: [<A HREF="#sm:jsr82"><CITE>M+05</CITE></A><CITE>, S. 93</CITE>]).<BR>
<BR>
Das vom JSR-82 definierte API erlaubt es einer Applikation
OBEX-Operationen zwischen Client und Server auszuf�hren. Allerdings
adressiert das API das <A NAME="@default100"></A>verbindungslose OBEX
nicht, wie dies in der OBEX Spezifikation der IrDA der Fall ist. Das
bereitgestellte OBEX API stellt die in
[Tab.: <A HREF="#tgl:jbt:comm:obex:ops">2.8</A>] dargestellten Operationen zur
Verf�gung.<BR>
<BR>
<A NAME="@default101"></A>
<BLOCKQUOTE CLASS="table"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
 <TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">Operation</SPAN></TD>
<TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">Beschreibung</SPAN></TD>
</TR>
<TR><TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">CONNECT</SPAN></TD>
<TD VALIGN=top ALIGN=left>Stellt die Verbindung zum Server her.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">PUT</SPAN></TD>
<TD VALIGN=top ALIGN=left>�bertr�gt Daten vom Client an den Server.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">GET</SPAN></TD>
<TD VALIGN=top ALIGN=left>�bertr�gt Daten vom Server an den Client.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">SETPATH</SPAN></TD>
<TD VALIGN=top ALIGN=left>�ndert das Arbeitsverzeichnis auf dem Server.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">ABORT</SPAN></TD>
<TD VALIGN=top ALIGN=left>Bricht eine <SPAN STYLE="font-variant:small-caps">PUT</SPAN> oder <SPAN STYLE="font-variant:small-caps">GET</SPAN> Operation ab.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">CREATE-EMPTY</SPAN></TD>
<TD VALIGN=top ALIGN=left>Erzeugt ein leeres Objekt mit dem im Header
 angegebenen Namen auf dem Server.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">PUT-DELETE</SPAN></TD>
<TD VALIGN=top ALIGN=left>L�scht das im Header angegebene Objekt auf dem
 Server.</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">DISCONNECT</SPAN></TD>
<TD VALIGN=top ALIGN=left>Beendet die Verbindung zum Server.</TD>
</TR></TABLE>
<DIV CLASS="center">Tabelle 2.8: OBEX Operationen</DIV>
<A NAME="tgl:jbt:comm:obex:ops"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Da das OBEX Protokoll �ber verschiedene Transportprotokolle verwendet
werden kann, muss der String, der die Verbindung spezifiziert, das
Transportprotokoll beinhalten. Die URL, um eine Verbindung zu einem
entfernten Ger�t herzustellen, hat folgenden Aufbau:<BR>
<BR>
<TT>{scheme}:[{target}{params}]</TT><BR>
<BR>
Um die zus�tzliche Verwendung des Protokolls bei OBEX deutlich zu
machen, wird, mit Ausnahme von OBEX �ber RFCOMM, folgendes Schema
verwendet:<BR>
<BR>
<TT>{transport}obex://{target}{params}</TT>. <BR>
<BR>
Wird RFCOMM als Transportprotokoll verwendet, ist der als
<TT>{scheme}</TT> gekennzeichnete Teil mit <TT>btgoep</TT> zu ersetzen
und <TT>{target}</TT> spezifiziert die Bluetooth-Adresse, sowie die
RFCOMM Kanalnummer. Alle f�r RFCOMM g�ltigen Parameter
(<TT>{params}</TT>) sind ebenfalls f�r OBEX �ber RFCOMM
g�ltig<SUP><A NAME="text35" HREF="#note35">35</A></SUP>. Ein g�ltiger
OBEX �ber RFCOMM Verbindungskennzeichner hat also die Form:<BR>
<BR>
Client: <TT>btgoep://0123456789ab:1;authenticate=yes</TT><BR>
Server: <TT>btgoep://localhost:DEADBEEFCAFEBABE5DADD115A1D1DEAD</TT><BR>
<BR>
Die von den anderen Verbindungskennzeichnern differente Schreibweise
r�hrt daher, dass das OBEX Protokoll mit Hilfe des in der
Bluetooth-Spezifikation definierten <I><FONT COLOR=maroon>Generic Object Exchange
 Profiles (GOEP)</FONT></I><SUP><A NAME="text36" HREF="#note36">36</A></SUP>
realisiert wurde [<A HREF="#sm:jsr82"><CITE>M+05</CITE></A><CITE>, S. 98</CITE>].
<BR>
<BR>
<!--TOC subsection JSR-82 Sicherheit-->

<H3 CLASS="subsection"><A NAME="htoc41">2.5.9</A>&nbsp;&nbsp;JSR-82 Sicherheit</H3><!--SEC END -->

<A NAME="tgl:jbt:sec"></A>
Im JSR-82 werden Methoden beschrieben, die es erm�glichen, eine
gesicherte Bluetooth-Kommunikation herzustellen. Es ist m�glich,
bereits beim Aufbau der Verbindung, durch einen entsprechend
angepassten <I><FONT COLOR=maroon>Connection String</FONT></I>, die Sicherheitsparameter
festzulegen. Methoden der <TT>javax.bluetooth.RemoteDevice</TT> Klasse
k�nnen benutzt werden, um Sicherheits�nderungen der bestehenden
Verbindung zu veranlassen. Die Definition und Belegung der Parameter
ist sehr umfangreich und wird in Kapitel 8 des JSR-82 detailliert
beschrieben. Die Beschreibung umfasst dabei, wie die
Sicherheitsanforderungen bereits beim Verbindungsaufbau festgelegt
oder Client und Server Authentifikations- oder
Verschl�sselungsforderungen stellen k�nnen [<A HREF="#sm:jsr82"><CITE>M+05</CITE></A><CITE>, S. 52ff</CITE>].

<BR>
<BR>

<!--BEGIN NOTES chapter-->
<HR WIDTH="50%" SIZE=1><DL CLASS="list"><DT CLASS="dt-list"><A NAME="note1" HREF="#text1"><FONT SIZE=5>1</FONT></A><DD CLASS="dd-list">Engl.&nbsp;: baseband, transceiver,
 protocolstack
<DT CLASS="dt-list"><A NAME="note2" HREF="#text2"><FONT SIZE=5>2</FONT></A><DD CLASS="dd-list"><I><FONT COLOR=maroon>Industrial, Scientific, and Medical
 Band</FONT></I> [<A HREF="#wp:ism"><CITE>Wik06c</CITE></A>]
<DT CLASS="dt-list"><A NAME="note3" HREF="#text3"><FONT SIZE=5>3</FONT></A><DD CLASS="dd-list">Illustration: [<A HREF="#bt:gfsk"><CITE>Bec05</CITE></A><CITE>, Folie
 9</CITE>]
<DT CLASS="dt-list"><A NAME="note4" HREF="#text4"><FONT SIZE=5>4</FONT></A><DD CLASS="dd-list">Siehe [<A HREF="#wp:mpv"><CITE>Wik06d</CITE></A>]
<DT CLASS="dt-list"><A NAME="note5" HREF="#text5"><FONT SIZE=5>5</FONT></A><DD CLASS="dd-list">Frequenzbereich des Nutzsignals (siehe
 [<A HREF="#wp:bb"><CITE>Wik06a</CITE></A>])
<DT CLASS="dt-list"><A NAME="note6" HREF="#text6"><FONT SIZE=5>6</FONT></A><DD CLASS="dd-list">engl.: <I><FONT COLOR=maroon>Logical Transport</FONT></I>, siehe
 [Kapitel <A HREF="#tgl:bt:pl:lt">2.1.2.1</A>]
<DT CLASS="dt-list"><A NAME="note7" HREF="#text7"><FONT SIZE=5>7</FONT></A><DD CLASS="dd-list">Der LM ist verantwortlich f�r die
 Erzeugung, Modifikation und Freigabe logischer Verbindungen
 [<A HREF="#bt:spez12"><CITE>Blu03</CITE></A><CITE>, Architecture, S. 23; PDF, S. 99</CITE>].
<DT CLASS="dt-list"><A NAME="note8" HREF="#text8"><FONT SIZE=5>8</FONT></A><DD CLASS="dd-list">Kurz: QoS,
 bezeichnet ein Verfahren, das einem (Paket-)Dienst eine
 Mindestbandbreite zusichert.
<DT CLASS="dt-list"><A NAME="note9" HREF="#text9"><FONT SIZE=5>9</FONT></A><DD CLASS="dd-list">Das <I><FONT COLOR=maroon>Host
 Controller Interface (HCI)</FONT></I> befindet sich zwischen logischem und L2CAP-Layer und stellt
 eine einheitliche Schnittstelle zum Bluetooth-Controller dar.
<DT CLASS="dt-list"><A NAME="note10" HREF="#text10"><FONT SIZE=5>10</FONT></A><DD CLASS="dd-list">Sogenanntes <I><FONT COLOR=maroon>Challenge-Response</FONT></I> Verfahren (siehe
[<A HREF="#jfms:kry"><CITE>FS06</CITE></A><CITE>, S. 56</CITE>])
<DT CLASS="dt-list"><A NAME="note11" HREF="#text11"><FONT SIZE=5>11</FONT></A><DD CLASS="dd-list">Siehe [<A HREF="#schb:ak"><CITE>Sch96</CITE></A><CITE>, S. 392ff</CITE>]
<DT CLASS="dt-list"><A NAME="note12" HREF="#text12"><FONT SIZE=5>12</FONT></A><DD CLASS="dd-list">Siehe <A HREF="https://www.bluetooth.org/"><TT>https://www.bluetooth.org/</TT></A>
<DT CLASS="dt-list"><A NAME="note13" HREF="#text13"><FONT SIZE=5>13</FONT></A><DD CLASS="dd-list">Siehe
 [Kapitel <A HREF="#tgl:midp">2.4</A>]
<DT CLASS="dt-list"><A NAME="note14" HREF="#text14"><FONT SIZE=5>14</FONT></A><DD CLASS="dd-list">Alle JSRs
 sind abrufbar unter: <A HREF="https://www.jcp.org/en/home/index"><TT>https://www.jcp.org/en/home/index</TT></A>
<DT CLASS="dt-list"><A NAME="note15" HREF="#text15"><FONT SIZE=5>15</FONT></A><DD CLASS="dd-list">Siehe <A HREF="https://java.sun.com/products/cldc/"><TT>https://java.sun.com/products/cldc/</TT></A>
<DT CLASS="dt-list"><A NAME="note16" HREF="#text16"><FONT SIZE=5>16</FONT></A><DD CLASS="dd-list">Siehe [<A HREF="#sm:jsr218"><CITE>C+05</CITE></A>]; Einordnung
 siehe [Abb.: <A HREF="#tgl:j2me:ein">2.3</A>]
<DT CLASS="dt-list"><A NAME="note17" HREF="#text17"><FONT SIZE=5>17</FONT></A><DD CLASS="dd-list">Siehe [Kapitel <A HREF="#tgl:midp">2.4</A>]
<DT CLASS="dt-list"><A NAME="note18" HREF="#text18"><FONT SIZE=5>18</FONT></A><DD CLASS="dd-list">Programme, die auf
 einem MID ausgef�hrt werden k�nnen.
<DT CLASS="dt-list"><A NAME="note19" HREF="#text19"><FONT SIZE=5>19</FONT></A><DD CLASS="dd-list">JSR-118: [<A HREF="#sm:jsr118"><CITE>VW02</CITE></A>]; JSR-37 [<A HREF="#sm:jsr37"><CITE>Van00</CITE></A>]
<DT CLASS="dt-list"><A NAME="note20" HREF="#text20"><FONT SIZE=5>20</FONT></A><DD CLASS="dd-list">Siehe [Kapitel <A HREF="#tgl:cldc">2.3</A>]
<DT CLASS="dt-list"><A NAME="note21" HREF="#text21"><FONT SIZE=5>21</FONT></A><DD CLASS="dd-list">Siehe
 [Kapitel <A HREF="#tgl:midp:rms">2.4.1</A>]
<DT CLASS="dt-list"><A NAME="note22" HREF="#text22"><FONT SIZE=5>22</FONT></A><DD CLASS="dd-list">Parallele Aufrufe einer Funktion auf einen
Datensatz/-block f�hren nicht zu Inkonsistenzen dessen.
<DT CLASS="dt-list"><A NAME="note23" HREF="#text23"><FONT SIZE=5>23</FONT></A><DD CLASS="dd-list">Siehe [Kapitel <A HREF="#tgl:cldc:sec">2.3.2</A>]
<DT CLASS="dt-list"><A NAME="note24" HREF="#text24"><FONT SIZE=5>24</FONT></A><DD CLASS="dd-list">Siehe <A HREF="https://www.jcp.org/en/jsr/detail?id=82"><TT>https://www.jcp.org/en/jsr/detail?id=82</TT></A>
<DT CLASS="dt-list"><A NAME="note25" HREF="#text25"><FONT SIZE=5>25</FONT></A><DD CLASS="dd-list">Version 1.1 kann
 unter <A HREF="https://www.bluetooth.org/spec/"><TT>https://www.bluetooth.org/spec/</TT></A> angefordert werden.
<DT CLASS="dt-list"><A NAME="note26" HREF="#text26"><FONT SIZE=5>26</FONT></A><DD CLASS="dd-list">Siehe
 [Kapitel <A HREF="#tgl:jbt:comm:obex">2.5.8.2</A>]
<DT CLASS="dt-list"><A NAME="note27" HREF="#text27"><FONT SIZE=5>27</FONT></A><DD CLASS="dd-list">Siehe [Kapitel <A HREF="#tgl:jbt:comm:spp">2.5.8.1</A>]
<DT CLASS="dt-list"><A NAME="note28" HREF="#text28"><FONT SIZE=5>28</FONT></A><DD CLASS="dd-list">Gross-/Kleinschreibung ist zu beachten.
<DT CLASS="dt-list"><A NAME="note29" HREF="#text29"><FONT SIZE=5>29</FONT></A><DD CLASS="dd-list">Siehe [Kapitel <A HREF="#tgl:bt:gap">2.1.5</A>]
<DT CLASS="dt-list"><A NAME="note30" HREF="#text30"><FONT SIZE=5>30</FONT></A><DD CLASS="dd-list">Siehe [Kapitel <A HREF="#tgl:cldc:gcf">2.3.1</A>]
<DT CLASS="dt-list"><A NAME="note31" HREF="#text31"><FONT SIZE=5>31</FONT></A><DD CLASS="dd-list">Siehe <A HREF="https://www.irda.org/"><TT>https://www.irda.org/</TT></A>
<DT CLASS="dt-list"><A NAME="note32" HREF="#text32"><FONT SIZE=5>32</FONT></A><DD CLASS="dd-list">Datenformat f�r eine elektronische
 Visitenkarte
<DT CLASS="dt-list"><A NAME="note33" HREF="#text33"><FONT SIZE=5>33</FONT></A><DD CLASS="dd-list">Siehe
 <A HREF="https://www.ietf.org/rfc/rfc2616.txt"><TT>https://www.ietf.org/rfc/rfc2616.txt</TT></A>
<DT CLASS="dt-list"><A NAME="note34" HREF="#text34"><FONT SIZE=5>34</FONT></A><DD CLASS="dd-list">OBEX wird aus diesem Grund auch gerne als bin�res
 HTTP bezeichnet.
<DT CLASS="dt-list"><A NAME="note35" HREF="#text35"><FONT SIZE=5>35</FONT></A><DD CLASS="dd-list">Siehe [Tab.: <A HREF="#tgl:jbt:comm:spp:vp">2.7</A>]
<DT CLASS="dt-list"><A NAME="note36" HREF="#text36"><FONT SIZE=5>36</FONT></A><DD CLASS="dd-list">Spezifikation: [<A HREF="#btsig:goep"><CITE>Blu05</CITE></A>]
</DL>
<!--END NOTES-->
<!--TOC chapter OBEX Object Passing-->

<H1 CLASS="chapter"><A NAME="htoc42">Kapitel&nbsp;3</A>&nbsp;&nbsp;OBEX Object Passing</H1><!--SEC END -->

<A NAME="impl"></A>
<A NAME="@default102"></A>
<A NAME="@default103"></A>
Mobile Endger�te verf�gen durch das GCF der CLDC �ber einen
Mechanismus, der es ihnen erlaubt, eine Verbindung zu einem anderen
Ger�t �ber ein Netzwerk herzustellen. Das Kommunikationsverhalten ist
jedoch, auf Grund der fehlenden M�glichkeit Java-Objekte zu
�bertragen, als eingeschr�nkt einzustufen. <BR>
<BR>
Als Vorstufe der �bertragung ist eine Serialisierung des Objekts
notwendig, sodass dieses �bertragen und beim Empf�nger wieder
deserialisiert werden kann. RMI beinhaltet einen solchen Mechanismus
um Objekte zu �bertragen. Mit dem JSR-66<SUP><A NAME="text37" HREF="#note37">1</A></SUP> &ndash; <I><FONT COLOR=maroon>RMI Optional
 Package (RMI OP)</FONT></I> &ndash; wurde
der RMI Mechanismus, der im J2EE Umfeld h�ufig im Zusammenhang mit
bspw. <I><FONT COLOR=maroon>Enterprise JavaBeans (EJB)</FONT></I> genannt wird, innerhalb der J2ME verf�gbar gemacht.
Als Nachteil dieser L�sung erweist sich jedoch der Umstand, dass die
RMI OP Erweiterung abh�ngig von der CDC ist, die von dem Vorhandensein
einer VM, welche die JVM Spezifikation vollst�ndig unterst�tzt,
abh�ngig ist. Ein Einsatz in Verbindung mit der CLDC ist, wegen der
fehlenden, vollst�ndigen JVM Unterst�tzung nicht
m�glich<SUP><A NAME="text38" HREF="#note38">2</A></SUP>.<BR>
<BR>
Es existieren allerdings andere Frameworks, die sich des Problems der
Serialisierung von Objekten mit der J2ME annehmen. Ein Vergleich der
Frameworks Javolution, kSOAP, Burlap/Hessian und RMI OP wurde in
[<A HREF="#br:objser"><CITE>BSM06</CITE></A>] durchgef�hrt. Als Ergebnis der Untersuchung wurde
festgestellt, dass keines der untersuchten Frameworks in der Lage ist,
ein komplexes Objekt innerhalb der J2ME (auf Basis der CLDC) zu
deserialisieren. W�re eine Serialisierung der Objekte mit Hilfe einer
der o.&nbsp;g. Frameworks m�glich gewesen, w�rden sie allerdings das
Problem der Daten�bertragung &ndash; abgesehen von RMI &ndash; nicht l�sen
k�nnen.<BR>
<BR>
Der Fokus der OOP Bibliothek liegt nicht auf der Serialisierung von
Objekten, wie dies auf Grund der Schnittstellendefinition evtl.
angenommen werden k�nnte, sondern vielmehr auf der effizienten,
einfachen �bertragung der Daten einfacher Objekte. Tiefe Kopien von
komplexen Objektstrukturen k�nnen, sofern sie vom Programmierer in
eine Byte-Array-Repr�sentation �berf�hrt und von dieser auch wieder
hergestellt werden k�nnen, ebenfalls mit dem Mechanismus �bertragen
werden. Die einfachste Methode jedoch ist es, die komplexe
Objektstruktur in eine einfache Darstellung zu �berf�hren. Falls es
das Projekt zul�sst, kann auf die CDC gewechselt werden, die einen
Mechanismus zur Serialisierung von Objekten bereitstellt, sodass die
zu �bertragenden Objekte sehr leicht in einer
Byte-Array-Repr�sentation erhalten werden k�nnen.<BR>
<BR>
Das <I><FONT COLOR=maroon>OBEX Object Passing (OOP)</FONT></I> stellt eine signifikante Vereinfachung der
�bertragung von Objekten �ber eine Bluetooth-Funkstrecke dar. <BR>
<BR>
Das Peer2Me Projekt<SUP><A NAME="text39" HREF="#note39">3</A></SUP>
scheint einen, dem OOP �hnlichen, Mechanismus zu implementieren. Die
Schnittstelle <TT>Persistent</TT> des Projekts weist die selbe Signatur
wie die Schnittstelle <TT>IObexObjectPassing</TT> der OOP Bibliothek
auf. Die Peer2Me Bibliothek baut auf der RFCOMM Schnittstelle auf. Um
Transportprotokollunabh�ngigkeit zu erreichen, wurde ein eigener
Mechanismus entwickelt (Vgl.&nbsp;: [<A HREF="#lcnm:p2me"><CITE>LN05</CITE></A><CITE>, S. 70</CITE>] und [<A HREF="#lcnm:p2me"><CITE>LN05</CITE></A><CITE>, S.
58</CITE>]). Eine genauere Untersuchung des Projekts liess sich,
auf Grund der sp�ten Entdeckung, nicht mehr realisieren.<BR>
<BR>
OOP setzt im Vergleich zu Peer2Me auf der OBEX Schicht auf. Die
Transportprotokollunabh�ngigkeit wird beim OOP durch eben diesen
Umstand erreicht. Das OOP passt sich wie in [Abb.: <A HREF="#impl:oopin">3.1</A>]
dargestellt in den Bluetooth-Protokollstapel ein.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing012.gif"><DIV CLASS="center">Abbildung 3.1: Einordnung von OOP im
 Bluetooth-Protokollstapel</DIV><A NAME="impl:oopin"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
<!--TOC section Technische Voraussetzungen-->

<H2 CLASS="section"><A NAME="htoc43">3.1</A>&nbsp;&nbsp;Technische Voraussetzungen</H2><!--SEC END -->

<A NAME="impl:tv"></A>
<A NAME="@default104"></A> Die Implementierung der Bibliothek
sowie die Umsetzung der Beispielapplikation, ist mit der Netbeans
IDE<SUP><A NAME="text40" HREF="#note40">4</A></SUP>
realisiert worden. Die Netbeans IDE wurde auf Grund pers�nlicher
Pr�ferenzen des Autors sowie der beispiellosen Integration des
<I><FONT COLOR=maroon>Wireless Toolkit</FONT></I>s <I><FONT COLOR=maroon>(WTK)</FONT></I><SUP><A NAME="text41" HREF="#note41">5</A></SUP> gew�hlt. Die
Integration des WTK erfolgt durch die zus�tzliche Installation des
sogenannten <I><FONT COLOR=maroon>Mobility Pack</FONT></I>s, das unter der selben URL gefunden
werden kann wie die IDE selbst. Die Applikationsentwicklung wird
durch die gute Integration der vom WTK bereitgestellten Emulatoren
wesentlich vereinfacht.<BR>
<BR>
Die Netbeans IDE ist auf nahezu allen Betriebssystemen, auf denen eine
JVM unterst�tzt wird, verf�gbar. Allerdings gilt dieser Umstand nur
f�r die IDE selbst.<A NAME="@default105"></A> Das f�r die
Entwicklung von J2ME Applikationen notwendige <I><FONT COLOR=maroon>Wireless Toolkit</FONT></I>
ist nicht f�r Macintosh Plattformen verf�gbar. Es ist jedoch m�glich,
durch den Einsatz eines alternativen Emulators, J2ME Applikationen auf
dem Macintosh zu entwickeln<SUP><A NAME="text42" HREF="#note42">6</A></SUP>.<BR>
<BR>
M�chte man, abgesehen von Applikationen f�r mobile Endger�te,
Applikationen entwickeln, die auf einem Desktop-Computer verwendet
werden sollen, ist die zus�tzliche Installation eines
Bluetooth-Stacks sowie einer JSR-82 Implementierung notwendig.<BR>
<BR>
<!--TOC subsection Bluetooth-Stack-->

<H3 CLASS="subsection"><A NAME="htoc44">3.1.1</A>&nbsp;&nbsp;Bluetooth-Stack</H3><!--SEC END -->

<A NAME="impl:tv:bts"></A>
<A NAME="@default106"></A> Beim Kauf eines Bluetooth-Adapters wird der
Stack i.&nbsp;d.&nbsp;R. vom Hersteller des Produkts mitgeliefert. Der
Funktionsumfang des mitgelieferten Stacks ist jedoch vom Hersteller
abh�ngig. Ein nicht mit dem Produkt gelieferter Bluetooth-Stack kann
(wahrscheinlich) installiert werden, jedoch ist die Beschaffung
desselben auf legalem Wege nicht zu erreichen. Linux verwendet einen
eigenen Bluetooth-Stack; den sogenannten BlueZ
Stack<SUP><A NAME="text43" HREF="#note43">7</A></SUP>. Die
Macintosh Plattform verwendet ebenfalls ihre Eigenentwicklung.<BR>
<BR>
<!--TOC subsection JSR-82 Implementierung-->

<H3 CLASS="subsection"><A NAME="htoc45">3.1.2</A>&nbsp;&nbsp;JSR-82 Implementierung</H3><!--SEC END -->

<A NAME="impl:tv:jsr82"></A>
<A NAME="@default107"></A>
<A NAME="@default108"></A>
Bei der Wahl der JSR-82 Implementierung ist ebenfalls Vorsicht
geboten. Die Implementierungen sind abh�ngig vom zu Grunde liegenden
Bluetooth-Stack. So kann es passieren, dass die gew�nschte JSR-82
Implementierung nicht mit dem auf dem System installierten
Bluetooth-Stack zusammenarbeitet. <BR>
<BR>
Um den JSR-82 auf realen Ger�ten einsetzen zu k�nnen, muss das
Endger�t Unterst�tzung f�r diesen bereitstellen. Dies ist bei den
meisten mobilen Endger�ten, wie z.&nbsp;B. Handys, oder PDAs gegeben. M�chte
man allerdings auf einem Desktop-Computer eine Bluetooth-Anwendung in
Betrieb nehmen, muss zus�tzlich zum Bluetooth-Stack eine JSR-82
Implementierung installiert werden. <BR>
<BR>
Die meisten Implementierungen werden in Form eines Java-Archivs und
einer Systembibliothek ausgeliefert. Es gibt allerdings auch
Ausnahmen, wie z.&nbsp;B. die Harald-<SUP><A NAME="text44" HREF="#note44">8</A></SUP> oder
JavaBluetooth-Implementierung<SUP><A NAME="text45" HREF="#note45">9</A></SUP>, die eine vollst�ndig in Java
realisierte JSR-82 Implementierung bereitstellen. Da die beiden
Alternativen allerdings das <TT>javax.comm</TT> Paket verwenden, muss
dieses zus�tzlich installiert werden. Hier hat man die Wahl zwischen
dem Paket von Sun<SUP><A NAME="text46" HREF="#note46">10</A></SUP>, und
einer RXTX<SUP><A NAME="text47" HREF="#note47">11</A></SUP> genannten
Implementierung. Die Installation und Konfiguration der Bibliotheken
erweist sich jedoch, im Vergleich zu den Paketen mit Systembibliothek
und Java-Archiv, schwieriger. Es existieren allerdings auch
Implementierungen, die lediglich in einem einzigen Java-Archiv
ausgeliefert werden. Sie laden die notwendigen nativen Bibliotheken
intern nach.<BR>
<BR>
Bei den verschiedenen verf�gbaren JSR-82 Implementierungen muss
zus�tzlich darauf geachtet werden, ob sie den JSR-82 vollst�ndig
(inklusive <TT>javax.obex</TT>) implementieren. Die Spezifikation l�sst
bei der Implementierung des OBEX Protokolls die Wahl, ob OBEX im zu
Grunde liegenden Bluetooth-System oder mit dem JSR-82 implementiert
wird<SUP><A NAME="text48" HREF="#note48">12</A></SUP>. Dieses Faktum
scheint von einigen JSR-82 Implementierungen falsch verstanden oder
bewusst weggelassen zu werden. In jedem Fall sollte die JSR-82
Implementierung die Schnittstellen exportieren bzw. sollten sie vom
JSR-82 API angesteuert werden k�nnen.<BR>
<BR>
Das Problem des fehlenden <TT>javax.obex</TT> Pakets kann durch den
Einsatz der avetanaOBEX<SUP><A NAME="text49" HREF="#note49">13</A></SUP> Bibliothek
kompensiert werden. Da viele mobile Endger�te ohnehin nur den
<TT>javax.bluetooth</TT> Teil der Spezifikation unterst�tzen, k�nnen
diese Ger�te durch den Einsatz der Bibliothek ebenfalls adressiert
werden. Ein allgemeines Nachr�sten der fehlenden OBEX Unterst�tzung
ist hingegen nicht m�glich. Die von der CLDC gesetzten
Sicherheitsstandards verbieten eine Nachr�stung von Funktionalit�t
durch externe Bibliotheken<SUP><A NAME="text50" HREF="#note50">14</A></SUP>,
was zur Folge hat, dass die Bibliothek in jeder Applikation
mitgeliefert werden muss, was auf den ohnehin schon mit knappem
Speicher bemessenen Ger�ten zus�tzlichen Speicherplatz in Anspruch
nimmt. <BR>
<BR>
F�r die vorliegende Arbeit ist auf dem Desktop-System der mit dem
<I><FONT COLOR=maroon>Service Pack 2</FONT></I> f�r Windows XP ausgelieferte Bluetooth-Stack
verwendet worden. Als JSR-82 Implementierung ist
BlueCove<SUP><A NAME="text51" HREF="#note51">15</A></SUP> auf Grund seiner freien
Verf�gbarkeit und einfachen Installation zum Einsatz gekommen.<BR>
<BR>

<!--TOC section Design-->

<H2 CLASS="section"><A NAME="htoc46">3.2</A>&nbsp;&nbsp;Design</H2><!--SEC END -->

<A NAME="impl:design"></A>
Das OBEX Protokoll ist pr�destiniert zur �bertragung gr�sserer Objekte
�ber ein Netzwerk. Die korrekte Fragmentierung der Daten, die
ansonsten manuell durchgef�hrt werden m�sste, ist innerhalb des
Protokolls vorgesehen und kann somit bei jeder OBEX Implementierung
vorausgesetzt werden. Bei Bluetooth bspw. muss die Fragmentierung,
sofern ein HCI vorhanden ist, sp�testens von der L2CAP Implementierung
durchgef�hrt werden<SUP><A NAME="text52" HREF="#note52">16</A></SUP>. Ein
weiterer Vorteil des OBEX Protokolls besteht in der Unabh�ngigkeit der
zu Grunde liegenden Transportprotokolle. So ist es bspw. m�glich OBEX
�ber TCP/IP zu verwenden. Dieses Verhalten sollte die Adaption des
OOP Verfahrens auf andere Transportprotokolle wesentlich vereinfachen.
F�r die Proof-Of-Concept Implementierung wurde OBEX �ber RFCOMM
gew�hlt<SUP><A NAME="text53" HREF="#note53">17</A></SUP>. Eine paketorientierte
�bersicht �ber die OOP Bibliothek ist in [Abb.: <A HREF="#impl:design:pov">3.2</A>]
zu sehen.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing013.gif"><DIV CLASS="center">Abbildung 3.2: Paket�bersicht der OBEX Object
 Passing Bibliothek</DIV><A NAME="impl:design:pov"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Der Aufbau der Bibliothek ist relativ simpel gehalten. Das &gt;&gt;oop&lt;&lt;
Paket beinhaltet lediglich das Interface der Bibliothek sowie die
Konstanten. Das &gt;&gt;util&lt;&lt; Paket beinhaltet Klassen, die zur
Realisierung der Bibliothek notwendig waren. Das &gt;&gt;impl&lt;&lt; Paket
beinhaltet diejenigen Klassen, welche die �bertragung der Daten letzten
Endes realisieren. Das &gt;&gt;exceptions&lt;&lt; Paket enth�lt die von der OOP
Bibliothek definierten Ausnahmen. Die Funktionalit�t der Klassen der
jeweiligen Pakete wird im folgenden erl�utert.<BR>
<BR>
<!--TOC subsection Paket &gt;&gt;oop&lt;&lt;-->

<H3 CLASS="subsection"><A NAME="htoc47">3.2.1</A>&nbsp;&nbsp;Paket &gt;&gt;oop&lt;&lt;</H3><!--SEC END -->

<A NAME="impl:design:doop"></A>
<A NAME="@default109"></A>
<A NAME="@default110"></A>
Wie in [Abb.: <A HREF="#impl:design:oopc">3.3</A>] zu sehen ist, befinden sich
lediglich zwei Klassen im &gt;&gt;oop&lt;&lt; Paket. Die Klassen haben folgende
Funktionalit�t: 
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description">
<A NAME="@default111"></A><B>IObexObjectPassing</B><DD CLASS="dd-description"> Dieses
 Interface muss von Entit�tsobjekten, welche die Daten kapseln,
 implementiert werden, um �bertragen werden zu k�nnen. Es zwingt
 den Programmierer dazu, die Methoden <TT>setObjectData(byte[]
 objectData)</TT> und <TT>getAsByteArray()</TT> zu implementieren, die
 zur korrekten Funktionsweise der Bibliothek notwendig sind. 
<DT CLASS="dt-description"><A NAME="@default112"></A><B>Constants</B><DD CLASS="dd-description"> Diese Klasse enth�lt die in
 der Bibliothek verwendeten Konstanten, sodass diese an einer
 zentralen Stelle ge�ndert werden k�nnen.
</DL>
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing014.gif"><DIV CLASS="center">Abbildung 3.3: Klassen des &gt;&gt;oop&lt;&lt; Pakets</DIV><A NAME="impl:design:oopc"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Durch Implementierung des <TT>IObexObjectPassing</TT> Interfaces ist
zus�tzlich eine einfache Weiterverarbeitung der Daten m�glich, sollen
diese persistent auf dem Ger�t gespeichert werden. Begr�ndet werden
kann dies durch die Limiterung, welchen den mobilen Endger�ten
auferlegt ist. Da sie laut der CLDC keine Kenntnis eines Dateisystems
vorweisen m�ssen<SUP><A NAME="text54" HREF="#note54">18</A></SUP>, ist ein
alternativer Mechanismus im MIDP zur Verf�gung gestellt worden; das
RMS<SUP><A NAME="text55" HREF="#note55">19</A></SUP>. Lese- und
Schreiboperationen auf das RMS k�nnen jedoch ausschliesslich in
Byte-Str�men durchgef�hrt werden. Durch die Implementierung der
<TT>IObexObjectPassing</TT> Schnittstelle sind die Entit�tsobjekte
bereits auf diese Aufgabe vorbereitet. Auf den Umgang mit dem RMS soll
an dieser Stelle jedoch nicht n�her eingegangen werden<SUP><A NAME="text56" HREF="#note56">20</A></SUP>.<BR>
<BR>
Die Bibliothek wurde bewusst mit einer Schnittstelle und nicht als
abstrakte Basisklasse modelliert. Gem�ss Balzert wird eine
Schnittstelle wie folgt beschrieben:
<BLOCKQUOTE CLASS="quotation">
 <I>&#8222;Es werden <B>funktionale Abstraktionen</B> in Form
 von Operationssignaturen bereitgestellt, die das &gt;&gt;Was&lt;&lt;, aber
 </I>nicht<I> das &gt;&gt;Wie&lt;&lt; festlegen. Eine Schnittstelle
 besteht also im Allgemeinen nur aus Operationssignaturen, d.&nbsp;h. sie besitzt keine Operationsr�mpfe und keine Attribute.
 Schnittstellen k�nnen jedoch in Vererbungsstrukturen verwendet
 werden. Eine Schnittstelle ist �quivalent zu einer Klasse, die
 keine Attribute und ausschlie�lich <B>abstrakte Operationen</B>
 besitzt.&#8220;</I> [<A HREF="#bl:ldswt"><CITE>Bal00</CITE></A><CITE>, S. 817</CITE>]
</BLOCKQUOTE>
Da in der Java Programmiersprache allerdings der Mechanismus der
Mehrfachvererbung nicht vorgesehen ist, w�re die Modellierung als
abstrakte Basisklasse f�r den Programmierer unvorteilhaft gewesen, da
eine Schnittstelle, im Gegensatz zur abstrakten Basisklasse, auf n-ter
Stufe der Erbhierarchie implementiert werden kann, wohingegen die
abstrakte Basisklasse an der Wurzel der Erbhierarchie implementiert
werden m�sste. 

<!--TOC subsection Paket &gt;&gt;impl&lt;&lt;-->

<H3 CLASS="subsection"><A NAME="htoc48">3.2.2</A>&nbsp;&nbsp;Paket &gt;&gt;impl&lt;&lt;</H3><!--SEC END -->

<A NAME="impl:design:dimpl"></A>
<A NAME="@default113"></A>
<A NAME="@default114"></A>
<A NAME="@default115"></A><A NAME="@default116"></A>Wie in
[Abb.: <A HREF="#impl:design:implc">3.5</A>] zu erkennen ist leiten diejenigen
Klassen, die zur �bertragung verwendet werden, von der Observer Klasse
im &gt;&gt;util&lt;&lt; Paket ab. Das Observer-Pattern, oder zu deutsch
Beobachter-Muster, erm�glicht es, Klassen, die von einem Objekt
abh�ngig sind, zu informieren, dass sich der Zustand des zu
�berwachenden Objekts ge�ndert hat. Dieses Pattern wird h�ufig in der
Programmierung graphischer Oberfl�chen eingesetzt, wenn eine graphische
Repr�sentation der Daten automatisch ge�ndert werden soll, sobald sich
der Datenbestand �ndert. Die Struktur des Patterns ist in
[Abb.: <A HREF="#impl:design:observerp">3.4</A>] abgebildet.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing015.gif"><DIV CLASS="center">Abbildung 3.4: Struktur des
 Observer-Patterns (Vgl.&nbsp;: [<A HREF="#bl:ldswt"><CITE>Bal00</CITE></A><CITE>, S. 849</CITE>])</DIV><A NAME="impl:design:observerp"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Die Klassen <TT>ObjectPusher</TT>, <TT>ObjectReceiver</TT> und
<TT>BulkObjectPusher</TT> aus [Abb.: <A HREF="#impl:design:implc">3.5</A>] stellen
dabei die in [Abb.: <A HREF="#impl:design:observerp">3.4</A>] als <I><FONT COLOR=maroon>Concrete
 Subject</FONT></I> bezeichnete Klasse dar.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing016.gif"><DIV CLASS="center">Abbildung 3.5: Klassen des &gt;&gt;impl&lt;&lt; Pakets</DIV><A NAME="impl:design:implc"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Die Funktionalit�t der im &gt;&gt;impl&lt;&lt; Paket enthaltenen Klassen ist
folgende: 
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description">
<A NAME="@default117"></A><B>ObjectReceiver</B><DD CLASS="dd-description"> Die
 <TT>ObjectReceiver</TT> Klasse wird verwendet um Objektdaten, die von
 der <TT>ObjectPusher</TT> Klasse versandt wurden, zu empfangen, um sie
 dann in einem Speicher empfangener Objekte abzulegen.
<DT CLASS="dt-description"><A NAME="@default118"></A><B>ObjectPusher</B><DD CLASS="dd-description"> Die
 <TT>ObjectPusher</TT> Klasse dient dem Zweck ein Objekt, welches das
 Interface <TT>IObexObjectPassing</TT> implementiert, zu versenden.
<DT CLASS="dt-description"><A NAME="@default119"></A><B>BulkObjectPusher</B><DD CLASS="dd-description"> Die Klasse
 <TT>BulkObjectPusher</TT> ist, wie der Name schon andeutet, dazu
 gedacht mehrere Objekte sequenziell in einem Aufruf zu �bertragen.
<DT CLASS="dt-description"><A NAME="@default120"></A><B>ReceiverRequestHandler</B><DD CLASS="dd-description">
 Diese Klasse ist notwendig, da in Java die M�glichkeit der
 Mehrfachvererbung nicht gegeben ist. Sie wird innerhalb der Klasse
 <TT>ObjectReceiver</TT> verwendet und bei der Initiierung einer
 Verbindung durch einen Client instanziert. Die Behandlung der
 <SPAN STYLE="font-variant:small-caps">PUT</SPAN> Anfrage<SUP><A NAME="text57" HREF="#note57">21</A></SUP> wird durch sie durchgef�hrt.
</DL>
Den Klassen <TT>ObjectReceiver</TT>, <TT>ObjectPusher</TT> und
<TT>BulkObjectPusher</TT> ist gemein, dass sie in einem separaten
Thread ablaufen. Dies ist bei der Anwendung der Klassen von Vorteil,
da sie den weiteren Programmablauf nicht st�ren. Der Transfer
der Daten wird dadurch im Hintergrund durchgef�hrt. Um �ber die
Beendigung des Datentransfers informiert zu werden, muss die
aufrufende Klasse das Interface <TT>Observer</TT> implementieren. Die
Verwendung der angesprochenen Klassen ist auch ohne Implementierung
des <TT>Observer</TT> Interfaces m�glich, jedoch verliert man die
M�glichkeit �ber die Beendigung der �bertragung informiert zu werden.
<!--TOC subsection Paket &gt;&gt;util&lt;&lt;-->

<H3 CLASS="subsection"><A NAME="htoc49">3.2.3</A>&nbsp;&nbsp;Paket &gt;&gt;util&lt;&lt;</H3><!--SEC END -->

<A NAME="impl:design:dutil"></A>
<A NAME="@default121"></A>
<A NAME="@default122"></A>
Im Paket &gt;&gt;util&lt;&lt; sind diejenigen Klassen enthalten, die nicht in direktem
Zusammenhang zur Implementierung stehen, jedoch zur Umsetzung derer
notwendig waren [Abb.: <A HREF="#impl:design:utilc">3.6</A>].
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing017.gif"><DIV CLASS="center">Abbildung 3.6: Klassen des &gt;&gt;util&lt;&lt; Pakets</DIV><A NAME="impl:design:utilc"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description">
<B>Observer</B><DD CLASS="dd-description"> Diese Klasse implementiert die in
 [Abb.: <A HREF="#impl:design:observerp">3.4</A>] dargestellte <I><FONT COLOR=maroon>Observer</FONT></I>
 Klasse. Die Implementierung ist an die aus der J2SE bekannte
 <TT>java.util.Observer</TT> Klasse angelehnt. Beim Entwurf der Klasse
 wurde auf Signaturgleichheit der Methoden geachtet.
<DT CLASS="dt-description"><B>Observable</B><DD CLASS="dd-description"> Diese Klasse implementiert die in
 [Abb.: <A HREF="#impl:design:observerp">3.4</A>] dargestellte <I><FONT COLOR=maroon>Subject</FONT></I>
 Klasse. Die Implementierung ist an die <TT>java.util.Observable</TT>
 Klasse aus der J2SE angelehnt. Ebenso wie bei der <I><FONT COLOR=maroon>Observer</FONT></I>
 Implementierung wurde auf die Signaturgleichheit der Methoden
 geachtet. 
<DT CLASS="dt-description"><B>OOPFinder</B><DD CLASS="dd-description"> Diese Klasse ist hilfreich, wenn die Methode
 <TT>DiscoveryAgent.selectService()</TT> von der verwendeten JSR-82
 Implementierung nicht unterst�tzt wird<SUP><A NAME="text58" HREF="#note58">22</A></SUP>. Diese Klasse stellt die Methode
 <TT>getConnectionURL()</TT> bereit, welche das Verhalten der Methode
 <TT>DiscoveryAgent.selectService()</TT> imitiert.
<DT CLASS="dt-description"><B>InspectBT</B><DD CLASS="dd-description"> Diese Klasse stellt die Methode
 <TT>getAllProperties()</TT> zur Verf�gung, mit deren Hilfe s�mtliche
 Eigenschaften des zu Grunde liegenden Bluetooth-Systems als String
 erhalten werden k�nnen. S�mtliche abgefragten Eigenschaften sind
 dabei, inklusive Erkl�rung, in [Tab.: <A HREF="#tgl:jbt:dp:dpt">2.6</A>]
 aufgelistet.
</DL>
M�chte man auf einem J2SE System aus bestimmten Gr�nden die
<I><FONT COLOR=maroon>Observable</FONT></I> und <I><FONT COLOR=maroon>Observer</FONT></I> Klassen der J2SE verwenden,
m�ssen, dank der Signaturgleichheit der Klassen, lediglich die
<TT>import</TT> Anweisungen der Bibliothek angepasst werden.

<!--TOC subsection Paket &gt;&gt;exceptions&lt;&lt;-->

<H3 CLASS="subsection"><A NAME="htoc50">3.2.4</A>&nbsp;&nbsp;Paket &gt;&gt;exceptions&lt;&lt;</H3><!--SEC END -->

<A NAME="impl:design:dexceptions"></A>
<A NAME="@default123"></A>
<A NAME="@default124"></A>
Das &gt;&gt;exceptions&lt;&lt; Paket definiert die in der Bibliothek verwendeten
Ausnahmen. Das Paket enth�lt momentan lediglich eine Ausnahme
[Abb.: <A HREF="#impl:design:exceptionsc">3.7</A>].
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing018.gif"><DIV CLASS="center">Abbildung 3.7: Klassen des &gt;&gt;exceptions&lt;&lt;
 Pakets</DIV><A NAME="impl:design:exceptionsc"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description">
<B>ObjectNotPassableException</B><DD CLASS="dd-description"> Diese Ausnahme wird geworfen wenn
 das zu �bertragende Objekt die Schnittstelle <TT>IObexObjectPassing</TT>
 nicht implementiert.
</DL>
<!--TOC section Deus ex machina-->

<H2 CLASS="section"><A NAME="htoc51">3.3</A>&nbsp;&nbsp;Deus ex machina</H2><!--SEC END -->

<A NAME="impl:dem"></A>
<A NAME="@default125"></A>
<A NAME="@default126"></A>
<A NAME="@default127"></A>
<A NAME="@default128"></A>
Die Funktionsweise des <I><FONT COLOR=maroon>OBEX Object Passing</FONT></I> wird anhand des
Sequenzdiagramms in [Abb.: <A HREF="#impl:dem:opseq">3.8</A>] im Folgenden erkl�rt.
Das dargestellte Diagramm zeigt den Versand eines einzelnen
Datenobjekts. Auf den Versand mehrerer Datenobjekte, der durch den
<TT>BulkObjectPusher</TT> realisiert ist, wird nicht eingegangen. Beim
<TT>BulkObjectPusher</TT> wird lediglich f�r jedes zu �bertragende
Objekt die Klasse <TT>ObjectPusher</TT> aufgerufen. Die Funktionsweise
des <TT>ObjectReceiver</TT>s wird im Zuge der Erkl�rung des
<TT>ObjectPusher</TT>s behandelt. Weitere Informationen zur
Implementierung des <TT>ObjectReceiver</TT>s sind in
[Kapitel <A HREF="#impl:dem:or">3.3.1</A>] zu finden.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing019.gif"><DIV CLASS="center">Abbildung 3.8: <TT>ObjectPusher</TT>
 Sequenzdiagramm</DIV><A NAME="impl:dem:opseq"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Nach der Erzeugung des <TT>ObjectPusher</TT> Objekts ruft es, durch
die interne Thread-Erzeugung, die Methode <TT>run()</TT> auf, in der die
eigentliche Arbeit des Objekts verrichtet wird.
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">[Schritt 1.1)]
In diesem Schritt wird die URL der Verbindung ermittelt, um das
 mobile Endger�t ansprechen zu k�nnen.
<LI CLASS="li-enumerate">Die Verbindung zum entfernten Ger�t wird hergestellt und die
 Sitzung etabliert.
<LI CLASS="li-enumerate">Mit Hilfe der vorhandenen Sitzung wird ein <TT>HeaderSet</TT> erzeugt.
<LI CLASS="li-enumerate">In das erzeugte <TT>HeaderSet</TT> wird der Name der zu
 �bertragenden Klasse in das Feld <TT>HeaderSet.NAME</TT> gesetzt.
<LI CLASS="li-enumerate">Der OBEX Transfer wird er�ffnet und das <TT>HeaderSet</TT> zum
 entfernten Ger�t �bertragen.
<LI CLASS="li-enumerate">Nachdem ein Ausgabestrom ge�ffnet wurde, werden die Daten mit
 der Methode <TT>getAsByteArray()</TT> aus dem Objekt extrahiert und
 zum entfernten Ger�t �bertragen. Dieses liest die eintreffenden
 Daten und speichert sie zun�chst tempor�r in einer Variablen ab. Der
 <TT>ObjectReceiver</TT> erzeugt aus der im <TT>HeaderSet</TT>
 �bermittelten Information des Klassennamens, mit Hilfe des
 <I><FONT COLOR=maroon>Classloaders</FONT></I> ein neues Objekt des �bermittelten Typs. Nachdem
 die Erzeugung abgeschlossen ist, werden die empfangenen Daten mit
 Hilfe der Methode <TT>setObjectData()</TT> in das erzeugte Objekt
 geschrieben. Das Objekt wird im n�chsten Schritt in einem
 <TT>Vector</TT> gespeichert, sodass dieses sp�ter zug�nglich ist.
<LI CLASS="li-enumerate">Der Zustand des Objekts wird auf ge�ndert gesetzt, da die
 �bertragung der Daten abgeschlossen ist.
<LI CLASS="li-enumerate">Die angeschlossenen <TT>Observer</TT> werden �ber das Ende der
 �bertragung informiert. (Die Klasse <TT>BulkObjectPusher</TT>
 realisiert durch diese Benachrichtigung ihr sequenzielles senden der
 Objekte).
</OL>
<!--TOC subsection ObjectReceiver-->

<H3 CLASS="subsection"><A NAME="htoc52">3.3.1</A>&nbsp;&nbsp;ObjectReceiver</H3><!--SEC END -->

<A NAME="impl:dem:or"></A>
Die Implementierung des <TT>ObjectReceiver</TT>s ver�ndert, bedingt
durch die Tatsache, dass sie einen Dienst zur Verf�gung stellt, den
Auffindbarkeitszustand des Ger�ts. Das Ger�t wird in den GIAC
Modus<SUP><A NAME="text59" HREF="#note59">23</A></SUP> versetzt, um permanent
auffindbar zu sein. Ist dieses Verhalten nicht gew�nscht, so muss es,
in der aktuellen Version der Bibliothek, im Quellcode ge�ndert werden.
Die Registrierung des Dienstes in der SDDB<SUP><A NAME="text60" HREF="#note60">24</A></SUP> wird von der avetanaOBEX Bibliothek, beim
Aufruf der Methode <TT>OBEXConnector.open()</TT>, vorgenommen. Diese
Registrierung ist notwendig, damit der OOP Dienst gefunden werden
kann. Die Implementierung der avetanaOBEX Bibliothek weist an dieser
Stelle jedoch einen kleinen Sch�nheitsfehler auf; so wird der Dienst in
der SDDB als SPP Dienst, anstelle eines OBEX Dienstes eingetragen, was
jedoch die Funktion nicht weiter st�rt.<BR>
<BR>
Ist die �nderung des Auffindbarkeitszustands, sowie die Registrierung
in der SDDB abgeschlossen, wartet das Objekt auf eingehende
Verbindungen. Da bei einem eintreffenden Client ein nebenl�ufiger
Prozess gestartet wird, erfolgt in der <TT>ObjectReceiver</TT> Klasse
eine synchronisation der Prozesse des <TT>ReceiverRequestHandler</TT>s
und der <TT>ObjectReceiver</TT> Klasse selbst. Der
<TT>ObjectReceiver</TT> wartet auf die Termination der
<TT>ReceiverRequestHandler</TT> Klasse bis er mit seiner Ausf�hrung
fortf�hrt. 

<!--TOC section Tests-->

<H2 CLASS="section"><A NAME="htoc53">3.4</A>&nbsp;&nbsp;Tests</H2><!--SEC END -->

<A NAME="impl:tests"></A>
<A NAME="@default129"></A>
<A NAME="@default130"></A>
Es sind im Rahmen der Entwicklung der Bibliothek rudiment�re Tests
durchgef�hrt worden. Diese Tests sind auf Grund des relativ hohen
Einarbeitungsaufwands nicht mit einem automatisierten Test-Rahmenwerk
wie z.&nbsp;B. JUnit<SUP><A NAME="text61" HREF="#note61">25</A></SUP>
durchgef�hrt worden. Tests sollten wegen der Affinit�t des Entwicklers
zu seinem Projekt, normalerweise niemals vom Entwickler selbst
durchgef�hrt werden. Da die Tests jedoch lediglich die w�hrend der
Entwicklungsphase durchgef�hrten Testszenarien reflektieren, m�ge dies
entschuldigt werden. Die durchgef�hrten Testf�lle sind in
[Tab.: <A HREF="#impl:tests:tftab">3.1</A>] zusammengefasst.
<BLOCKQUOTE CLASS="table"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
 <TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">Testbeschreibung</SPAN></TD>
<TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">Erwartetes Ergebnis</SPAN></TD>
<TD VALIGN=top ALIGN=left><SPAN STYLE="font-variant:small-caps">Test Erf�llt</SPAN></TD>
</TR>
<TR><TD VALIGN=top ALIGN=left>Es wird versucht ein Objekt zu �bertragen, dass die Schnittstelle
 <TT>IObexObjectPassing</TT> nicht implementiert.</TD>
<TD VALIGN=top ALIGN=left>Die �bertragung
 wird abgebrochen.</TD>
<TD VALIGN=top ALIGN=left>Ja</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left>Sind die Daten am Empfangsger�t korrekt rekonstruiert worden?</TD>
<TD VALIGN=top ALIGN=left>Korrekte Rekonstruktion der Daten.</TD>
<TD VALIGN=top ALIGN=left>Ja</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left>Es existieren zwei Ger�te auf denen der Server
 <TT>ObjectReceiver</TT> gestartet wurde.</TD>
<TD VALIGN=top ALIGN=left>Die
 Implementierung informiert den Anwender, dass mehrere Ger�te
 verf�gbar sind.</TD>
<TD VALIGN=top ALIGN=left>Nein<SUP><A NAME="text62" HREF="#note62">26</A></SUP></TD>
</TR>
<TR><TD VALIGN=top ALIGN=left>Es wird versucht zu senden, jedoch ist am Empfangsger�t keine
 <TT>ObjectReceiver</TT> Instanz erzeugt worden.</TD>
<TD VALIGN=top ALIGN=left>Die Methode <TT>OOPFinder.getConnectionURL()</TT> liefert
 <TT>null</TT>.</TD>
<TD VALIGN=top ALIGN=left>Ja</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left>Wird nach einer abgelehnten Verbindung durch das BCC eine erneute R�ckfrage an
 den Benutzer gestellt?</TD>
<TD VALIGN=top ALIGN=left>R�ckfrage wird erneut gestellt.</TD>
<TD VALIGN=top ALIGN=left>Nein<SUP><A NAME="text63" HREF="#note63">27</A></SUP></TD>
</TR>
<TR><TD VALIGN=top ALIGN=left>Besteht die M�glichkeit <TT>ObjectReceiver</TT> und <TT>BulkObjectPusher</TT>
 parallel auf einem Ger�t zu instanziieren?</TD>
<TD VALIGN=top ALIGN=left>Beide k�nnen parallel
 gestartet werden.</TD>
<TD VALIGN=top ALIGN=left>Ja</TD>
</TR></TABLE>
<DIV CLASS="center">Tabelle 3.1: W�hrend der Entwicklung durchgef�hrte Testf�lle</DIV>
<A NAME="impl:tests:tftab"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Die Testreihe konnte auf Grund mangelnder Hardware nicht auf zwei
reale Mobiltelefone ausgedehnt werden. Der Versuch mit Hilfe der
Bibliothek Daten von einem Laptop auf ein Mobiltelefon zu �bertragen,
schlug ebenfalls fehl. Das entfernte Ger�t konnte weder vom Laptop
noch vom Mobiltelefon aus gefunden werden. <BR>
<BR>
Eine Untersuchung der Eigenschaften des Ger�ts, mit Hilfe der Klasse
<TT>InspectBT</TT>, f�rderte zu Tage, dass das verwendete Mobiltelefon
(Nokia 6230) w�hrend es mit einem Ger�t gekoppelt ist, weder auf eine
Suchanfrage antworten, noch eine initiieren kann. Dieses Verhalten
jedoch ist f�r die korrekte Funktionsweise der OOP Bibliothek
relevant.<BR>
<BR>
Die verwendete JSR-82 Implementierung des Laptops lieferte bei allen
abgefragten Eigenschaften <TT>null</TT> als Ergebnis. Das bedeutet, dass
die Eigenschaft nicht implementiert ist oder die JSR-82
Implementierung falsch reagiert. Weiterhin bedeutet dies, dass selbst bei
korrektem Verhalten des Mobiltelefons, immer noch die verwendete JSR-82
Implementierung fehlerhaft sein k�nnte. <BR>
<BR>

<!--BEGIN NOTES chapter-->
<HR WIDTH="50%" SIZE=1><DL CLASS="list"><DT CLASS="dt-list"><A NAME="note37" HREF="#text37"><FONT SIZE=5>1</FONT></A><DD CLASS="dd-list">Siehe
 <A HREF="https://www.jcp.org/en/jsr/detail?id=66"><TT>https://www.jcp.org/en/jsr/detail?id=66</TT></A>
<DT CLASS="dt-list"><A NAME="note38" HREF="#text38"><FONT SIZE=5>2</FONT></A><DD CLASS="dd-list">Architekturelle Einordnung siehe [Abb.
 <A HREF="#tgl:j2me:ein">2.3</A>, S. <A HREF="#tgl:j2me:ein">??</A>]
<DT CLASS="dt-list"><A NAME="note39" HREF="#text39"><FONT SIZE=5>3</FONT></A><DD CLASS="dd-list">Siehe <A HREF="https://www.peer2me.org/"><TT>https://www.peer2me.org/</TT></A>
<DT CLASS="dt-list"><A NAME="note40" HREF="#text40"><FONT SIZE=5>4</FONT></A><DD CLASS="dd-list">Erh�ltlich unter <A HREFhttps:////www.netbeans.org/"><Thttps:////www.netbeans.org/</TT></A>
<DT CLASS="dt-list"><A NAME="note41" HREF="#text41"><FONT SIZE=5>5</FONT></A><DD CLASS="dd-list">Separat erh�ltlich unter
 <A HREF="https://java.sun.com/products/sjwtoolkit/"><TT>https://java.sun.com/products/sjwtoolkit/</TT></A>
<DT CLASS="dt-list"><A NAME="note42" HREF="#text42"><FONT SIZE=5>6</FONT></A><DD CLASS="dd-list">Anleitung zur Konfiguration der
 IDE unter [<A HREF="#lh:macos"><CITE>Has06</CITE></A>]
<DT CLASS="dt-list"><A NAME="note43" HREF="#text43"><FONT SIZE=5>7</FONT></A><DD CLASS="dd-list">Erh�ltlich unter <A HREFhttps:////www.bluez.org/"><Thttps:////www.bluez.org/</TT></A>
<DT CLASS="dt-list"><A NAME="note44" HREF="#text44"><FONT SIZE=5>8</FONT></A><DD CLASS="dd-list">Siehe
 <A HREF="https://www.control.lth.se/~johane/harald/"><TT>https://www.control.lth.se/~johane/harald/</TT></A>
<DT CLASS="dt-list"><A NAME="note45" HREF="#text45"><FONT SIZE=5>9</FONT></A><DD CLASS="dd-list">Siehe
 <A HREF="https://www.javabluetooth.org/"><TT>https://www.javabluetooth.org/</TT></A>
<DT CLASS="dt-list"><A NAME="note46" HREF="#text46"><FONT SIZE=5>10</FONT></A><DD CLASS="dd-list">Siehe
 <A HREF="https://www.sun.com/download/products.xml?id=43208d3d"><TT>https://www.sun.com/download/products.xml?id=43208d3d</TT></A>
<DT CLASS="dt-list"><A NAME="note47" HREF="#text47"><FONT SIZE=5>11</FONT></A><DD CLASS="dd-list">Siehe <A HREF="https://www.rxtx.org/"><TT>https://www.rxtx.org/</TT></A>
<DT CLASS="dt-list"><A NAME="note48" HREF="#text48"><FONT SIZE=5>12</FONT></A><DD CLASS="dd-list">Siehe [Kapitel <A HREF="#tgl:jbt:anf:obeximpl">2.5.1</A>]
<DT CLASS="dt-list"><A NAME="note49" HREF="#text49"><FONT SIZE=5>13</FONT></A><DD CLASS="dd-list">Erh�ltlich unter
 <A HREF="https://sourceforge.net/projects/avetanaobex/"><TT>https://sourceforge.net/projects/avetanaobex/</TT></A>
<DT CLASS="dt-list"><A NAME="note50" HREF="#text50"><FONT SIZE=5>14</FONT></A><DD CLASS="dd-list">Siehe [Kapitel <A HREF="#tgl:cldc:sec:als">2.3.2</A>]
<DT CLASS="dt-list"><A NAME="note51" HREF="#text51"><FONT SIZE=5>15</FONT></A><DD CLASS="dd-list">Erh�ltlich unter
 <A HREF="https://sourceforge.net/projects/bluecove/"><TT>https://sourceforge.net/projects/bluecove/</TT></A>;
 Installationsanleitung unter [<A HREF="#bc:doc"><CITE>Lab06</CITE></A>]
<DT CLASS="dt-list"><A NAME="note52" HREF="#text52"><FONT SIZE=5>16</FONT></A><DD CLASS="dd-list">Siehe [Kapitel <A HREF="#tgl:bt:l2cap">2.1.3</A>]
<DT CLASS="dt-list"><A NAME="note53" HREF="#text53"><FONT SIZE=5>17</FONT></A><DD CLASS="dd-list">Siehe [Kapitel <A HREF="#tgl:jbt:comm">2.5.8</A>]
<DT CLASS="dt-list"><A NAME="note54" HREF="#text54"><FONT SIZE=5>18</FONT></A><DD CLASS="dd-list">Siehe [Kapitel <A HREF="#tgl:cldc:fs">2.3</A>]
<DT CLASS="dt-list"><A NAME="note55" HREF="#text55"><FONT SIZE=5>19</FONT></A><DD CLASS="dd-list">Siehe [Kapitel <A HREF="#tgl:midp:rms">2.4.1</A>]
<DT CLASS="dt-list"><A NAME="note56" HREF="#text56"><FONT SIZE=5>20</FONT></A><DD CLASS="dd-list">Eine
 Einf�hrung ist unter [<A HREF="#sg:rms"><CITE>Gho06</CITE></A>] zu finden.
<DT CLASS="dt-list"><A NAME="note57" HREF="#text57"><FONT SIZE=5>21</FONT></A><DD CLASS="dd-list">Siehe
 [Tab.: <A HREF="#tgl:jbt:comm:obex:ops">2.8</A>]
<DT CLASS="dt-list"><A NAME="note58" HREF="#text58"><FONT SIZE=5>22</FONT></A><DD CLASS="dd-list">Dies ist z.&nbsp;B. beim
 BlueCove-Stack der Fall.
<DT CLASS="dt-list"><A NAME="note59" HREF="#text59"><FONT SIZE=5>23</FONT></A><DD CLASS="dd-list">Siehe [Kapitel <A HREF="#tgl:bt:gap:disc">2.4</A>]
<DT CLASS="dt-list"><A NAME="note60" HREF="#text60"><FONT SIZE=5>24</FONT></A><DD CLASS="dd-list">Siehe
 [Kapitel <A HREF="#tgl:jbt:cs">2.5.5</A>]
<DT CLASS="dt-list"><A NAME="note61" HREF="#text61"><FONT SIZE=5>25</FONT></A><DD CLASS="dd-list">Erh�ltlich unter <A HREFhttps:////www.junit.org/"><Thttps:////www.junit.org/</TT></A>
<DT CLASS="dt-list"><A NAME="note62" HREF="#text62"><FONT SIZE=5>26</FONT></A><DD CLASS="dd-list">Die Implementierung w�hlt das
 erste verf�gbare Ger�t.
<DT CLASS="dt-list"><A NAME="note63" HREF="#text63"><FONT SIZE=5>27</FONT></A><DD CLASS="dd-list">Ergebnis ist abh�ngig von der Implementierung des
 BCC [<A HREF="#sm:jsr82"><CITE>M+05</CITE></A><CITE>, S. 53</CITE>]
</DL>
<!--END NOTES-->
<!--TOC chapter Entwickeln mit OOP-->

<H1 CLASS="chapter"><A NAME="htoc54">Kapitel&nbsp;4</A>&nbsp;&nbsp;Entwickeln mit OOP</H1><!--SEC END -->

<A NAME="oopdev"></A>
<A NAME="@default131"></A>
In diesem Kapitel wird demonstriert, wie die OOP Bibliothek eingesetzt
werden kann. Um die zur Demonstration entwickelte Beispielapplikation
verstehen zu k�nnen, wird an dieser Stelle kurz auf die Grundlagen der
J2ME Programmierung eingegangen. Die Kenntnis der Grundlegenden
Sprachkonstrukte von Java sowie das Verst�ndnis einfacher
Datenstrukturen und -container wird vorausgesetzt.<BR>
<BR>
<!--TOC section Grundlagen der J2ME Programmierung-->

<H2 CLASS="section"><A NAME="htoc55">4.1</A>&nbsp;&nbsp;Grundlagen der J2ME Programmierung</H2><!--SEC END -->

<A NAME="oopdev:gdjp"></A>
<A NAME="@default132"></A>
Die J2ME ist, wie bereits in [Abb.: <A HREF="#tgl:j2me:ein">2.3</A>] gezeigt, im
Java Umfeld einzuordnen. Java Programme, die auf einem mobilen Endger�t
ausgef�hrt werden k�nnen, werden als MIDlets bezeichnet. Die
Namensgebung folgt aus dem Zusammenschluss von MID <I><FONT COLOR=maroon>(Mobile
 Information Device)</FONT></I> und Applet. Der haupts�chliche Unterschied zur
J2SE besteht im limiterten Sprachumfang der J2ME. Der signifikante
Unterschied der beiden Umgebungen ist auf die Beschaffenheit der
Hardware zur�ckzuf�hren, die wie bereits in [Kapitel <A HREF="#tgl:cldc:hwr">2.3</A>] und
[Kapitel <A HREF="#tgl:jbt:anf:hw">2.5.1</A>] gezeigt, im J2ME Umfeld mit starken
Einschr�nkungen belegt ist.<BR>
<BR>
<!--TOC subsection Lebenszyklus eines MIDlets-->

<H3 CLASS="subsection"><A NAME="htoc56">4.1.1</A>&nbsp;&nbsp;Lebenszyklus eines MIDlets</H3><!--SEC END -->

<A NAME="oopdev:gdjp:mlc"></A>
<A NAME="@default133"></A>
Jedes MIDlet ist gezwungen von der <TT>MIDlet</TT> Klasse zu erben. Sie
erm�glicht das korrekte starten, stoppen und aufr�umen des
MIDlets. Eine MIDlet darf, im Gegenteil zu J2SE Programmen, nicht �ber
eine <TT>public static void main()</TT> Methode verf�gen. Ist dies
trotzdem der Fall wird sie von der <I><FONT COLOR=maroon>Application Management
 Software (AMS)</FONT></I>
ignoriert [<A HREF="#sm:jsr118"><CITE>VW02</CITE></A><CITE>, S. 438</CITE>]. <BR>
<BR>
Die AMS ist Bestandteil des Betriebssystems des mobilen Endger�ts. Sie
erm�glicht die Ausf�hrung des MIDlets (und ggf. auch die
Installation/Deinstallation dessen). Weiterhin ist die AMS in der Lage
das MIDlet zu pausieren oder es zu stoppen. Der Zustandsautomat eines
MIDlets ist in [Abb.: <A HREF="#oopdev:gdjp:mlc:mll">4.1</A>] dargestellt.
<A NAME="@default134"></A>
<A NAME="@default135"></A>
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing020.gif"><DIV CLASS="center">Abbildung 4.1: Zustandsautomat
eines MIDlets (Vgl.: [<A HREF="#sm:jsr118"><CITE>VW02</CITE></A><CITE>, S. 440</CITE>])</DIV><A NAME="oopdev:gdjp:mlc:mll"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Die Struktur des Zustandsautomaten wird im Code durch die an den
Zustand�berg�ngen in [Abb.: <A HREF="#oopdev:gdjp:mlc:mll">4.1</A>] annotierten Methoden
realisiert. Das Betriebssystem ist dadurch in der Lage beim Eintreffen
eines externen Ereignisses, wie z.&nbsp;B. einem eingehenden Anruf, die
Methode <TT>pauseApp()</TT> aufzurufen, durch die das MIDlet bis zu
Fortf�hrung pausiert wird. [Listing <A HREF="#oopdev:gdjp:mlc:hwm">1</A>] zeigt ein
einfaches &#8222;Hello World&#8220; MIDlet um den Sachverhalt zu verdeutlichen.<BR>
<BR>
<A NAME="@default136"></A>
<DIV CLASS="center">Listing&nbsp;1: <A NAME="oopdev:gdjp:mlc:hwm"></A>Hello World MIDlet</DIV><BR>
<DIV CLASS="lstlisting"><FONT SIZE=2>    </FONT> 
<FONT SIZE=2>    </FONT> <B>package</B> hello;
<FONT SIZE=2>    </FONT> 
<FONT SIZE=2>    </FONT> <B>import</B> javax.microedition.midlet.*;
<FONT SIZE=2>   5</FONT> <B>import</B> javax.microedition.lcdui.*;
<FONT SIZE=2>    </FONT> 
<FONT SIZE=2>    </FONT> <B>public</B> <B>class</B> Test <B>extends</B> MIDlet {
<FONT SIZE=2>    </FONT>     <B>private</B> TextBox tf;
<FONT SIZE=2>    </FONT> 
<FONT SIZE=2>  10</FONT>     <B>public</B> Test() {
<FONT SIZE=2>    </FONT>         tf = <B>new</B> TextBox("Hello", "World", 20, TextField.UNEDITABLE);
<FONT SIZE=2>    </FONT>     }
<FONT SIZE=2>    </FONT> 
<FONT SIZE=2>    </FONT>     <B>public</B> <B>void</B> startApp() {
<FONT SIZE=2>  15</FONT>         Display.getDisplay(<B>this</B>).setCurrent(tf);
<FONT SIZE=2>    </FONT>     }
<FONT SIZE=2>    </FONT> 
<FONT SIZE=2>    </FONT>     <B>public</B> <B>void</B> pauseApp() {}
<FONT SIZE=2>    </FONT>     <B>public</B> <B>void</B> destroyApp(<B>boolean</B> unconditional) {}
<FONT SIZE=2>  20</FONT> }</DIV><BR>
<BR>
<!--TOC subsection User-Interface Entwicklung-->

<H3 CLASS="subsection"><A NAME="htoc57">4.1.2</A>&nbsp;&nbsp;User-Interface Entwicklung</H3><!--SEC END -->

<A NAME="oopdev:gdjp:uid"></A>
Um die User-Interface Entwicklung eines MIDlets zu vereinfachen, kann
ein sogenannter <I><FONT COLOR=maroon>Screen Designer</FONT></I> eingesetzt werden. Die Netbeans
Entwicklungsumgebung bietet einen solchen mit dem <I><FONT COLOR=maroon>Mobility Pack</FONT></I>
an<SUP><A NAME="text64" HREF="#note64">1</A></SUP>. Des weiteren bietet
es einen sogenannten <I><FONT COLOR=maroon>Flow Designer</FONT></I>, mit dessen Hilfe einzelne
&#8222;Seiten&#8220;, sogenannte <I><FONT COLOR=maroon>Forms</FONT></I>, leicht untereinander verk�pft
werden k�nnen. M�chte man keine Spiele oder Programme mit
anspruchsvollen graphischen Elementen entwickeln, l�sst sich mit den
dargebotenen Werkzeugen relativ schnell das Frontend einer Applikation
entwickeln. Um das Basisset der graphischen Elemente dennoch mit einer
ansprechenderen Optik zu versehen, wurde das <I><FONT COLOR=maroon>J2ME
 Polish</FONT></I><SUP><A NAME="text65" HREF="#note65">2</A></SUP> Projekt ins
Leben gerufen. J2ME Polish l�sst sich, zumindest laut Angabe der
Entwickler, ebenfalls in die Netbeans IDE integrieren<SUP><A NAME="text66" HREF="#note66">3</A></SUP>.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing021.gif"><DIV CLASS="center">Abbildung 4.2: Netbeans Flow Designer</DIV><A NAME="oopdev:gdjp:uid:flow"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Die [Abb.: <A HREF="#oopdev:gdjp:uid:flow">4.2</A>] zeigt den <I><FONT COLOR=maroon>Flow Designer</FONT></I>
f�r ein &#8222;Hello World&#8220; Projekt. Wie zu sehen ist, verbindet man den
Startpunkt der Applikation direkt mit der nach dem Start des MIDlets
anzuzeigenden Form. Wird der mit Exit beschriftete Button des MIDlets
gedr�ckt, terminiert die Applikation. Die Handhabung der Netbeans
IDE, bez�glich
der Applikationsentwicklung im J2ME Umfeld, soll an dieser Stelle
nicht weiter vertieft werden<SUP><A NAME="text67" HREF="#note67">4</A></SUP>.

<!--TOC section Projektorganisation-->

<H2 CLASS="section"><A NAME="htoc58">4.2</A>&nbsp;&nbsp;Projektorganisation</H2><!--SEC END -->

<A NAME="oopdev:po"></A>
<A NAME="@default137"></A>
<A NAME="@default138"></A>
Wie bei jedem gr�sseren Projekt, ist es auch bei der Entwicklung von
Applikationen f�r mobile Endger�te sinnvoll, f�r die verwendeten
Entit�tsobjekte eine Bibliothek zu erzeugen. Dadurch kann eine
mehrfache Implementierung der Entit�tsobjekte f�r differente
Plattformen vermieden werden. M�chte man also eine Applikation
entwickeln, die es erm�glicht, Daten zwischen einem Desktop-Computer
und einem mobilen Endger�t auszutauschen, ist dieser Ansatz jedem
anderen vorzuziehen. Da die OOP Bibliothek in der Lage ist, sowohl im
J2SE, als auch im J2ME Umfeld zu operieren, bietet es sich an diese
Form der Projektorganisation prinzipiell zu verwenden, da man sich so
die M�glichkeit offen h�lt, einen Client f�r andere Plattformen zu
implementieren. Eine beispielhafte Projektkonfiguration ist dann wie
folgt gestaltet.
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description">
<B>MeineApplikation-J2ME</B><DD CLASS="dd-description"> Dieses Projekt beinhaltet den Code der
 notwendig ist, um die Logik und die Anzeige des mobilen Endger�ts
 entsprechend der Anforderung zu manipulieren. 
<DT CLASS="dt-description"><B>MeineApplikation-J2SE</B><DD CLASS="dd-description"> Dieses Projekt beinhaltet den Code der
 Applikationslogik sowie die notwendigen Manipulationen der Anzeige,
 um eine �nderung der Entit�tsobjekte zu erm�glichen.
<DT CLASS="dt-description"><B>MeineApplikation-Entit�tsobjekte</B><DD CLASS="dd-description"> In diesem Projekt sind einzig
 die zu beiden Projekten geh�renden Entit�tsobjekte zu finden. Sollte
 eine �nderung der Entit�tsobjekte erfolgen, wirkt sich die �nderung
 unweigerlich auf beide Projekte aus, womit sich eine Duplikation des
 Codes vermeiden l�sst. 
</DL>

<!--TOC section Beispielapplikation-->

<H2 CLASS="section"><A NAME="htoc59">4.3</A>&nbsp;&nbsp;Beispielapplikation</H2><!--SEC END -->

<A NAME="oopdev:bspa"></A>
<A NAME="@default139"></A>
<A NAME="@default140"></A>
Die Funktionsweise sowie der konkrete Einsatz der Bibliothek wird
anhand einer J2ME Beispielapplikation demonstriert. Die Applikation
ist bewusst sehr einfach gehalten. So existieren keine zus�tzlichen
<I><FONT COLOR=maroon>Forms</FONT></I> mit deren Hilfe die Entit�tsobjekte manipuliert werden
k�nnen. Eine Manipulation der Daten ist f�r die Demonstration nicht
erforderlich. Die Applikation bietet allerdings die M�glichkeit zur
visuellen Repr�sentation der Daten, damit die korrekte �bertragung
derer verifiziert werden kann.<BR>
<BR>
Die Beispielapplikation ist mit Hilfe des in Netbeans integrierten
Emulators entwickelt worden. Zur Demonstration der Bibliothek muss der
Emulator zweimal gestartet werden. Durch die F�higkeit des Emulators
eine Bluetooth-Schnittstelle zu emulieren, kann die Applikation ohne
einen vorhandenen Bluetooth-Stack getestet werden. Netbeans ist
allerdings nicht in der Lage die Bluetooth-Schnittstelle von einer
J2SE Applikation auf ein J2ME Projekt zu emulieren, weswegen sich die
Beispielapplikation auf ein J2ME Programm beschr�nkt.<BR>
<BR>
Die Funktionsweise des Programms ist relativ einfach. Nachdem das
Projekt in Netbeans importiert wurde, muss das Programm zweimal
gestartet werden. Auf einem der beiden simulierten Ger�te wird nun der
Empfangsdienst gestartet. Man kann sich nun auf Wunsch die
vorhandenen Daten anzeigen lassen. Das Programm reagiert mit einer
Fehlermeldung, dass keine Daten vorhanden sind. Auf dem anderen Ger�t
wird im n�chsten Schritt die �bertragung der (im Code konfigurierten)
Daten veranlasst. Ist die �bertragung der Daten abgeschlossen, wird
ein Dialogelement angezeigt, welches das Ende der �bertragung
signalisiert. Auf dem empfangenden Ger�t k�nnen die Daten jetzt
angezeigt werden. Die Zustands�berg�nge der Beispielapplikation sind
in [Abb.: <A HREF="#oopdev:bspa:trans">4.3</A>], ein bebilderter Ablauf in
[Abb.: <A HREF="#oopdev:bspa:pics">4.4</A>] dargestellt.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing022.gif"><DIV CLASS="center">Abbildung 4.3: Zustands�berg�nge der J2ME
 Beispielapplikation</DIV><A NAME="oopdev:bspa:trans"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Da innerhalb der Applikation keine M�glichkeit besteht die zu
�bertragenden Daten zu manipulieren bzw. zu setzen, werden die Daten
innerhalb des Programmcodes direkt zugewiesen. Die Konfiguration eines
<TT>Person</TT> Objekts, das die Schnittstelle
<TT>IObexObjectPassing</TT> implementiert, erfolgt wie in Listing
[Listing <A HREF="#oopdev:bspa:bop">2</A>] gezeigt. Das Beispiel zeigt wie zwei
<TT>Person</TT> Objekte konfiguriert, und anschliessend mit der Klasse
<TT>BulkObjectPusher</TT> versendet werden k�nnen.<BR>
<BR>
<A NAME="@default141"></A>
<DIV CLASS="center">Listing&nbsp;2: <A NAME="oopdev:bspa:bop"></A>Verwendung von
 <TT>BulkObjectPusher</TT></DIV><BR>
<DIV CLASS="lstlisting"><FONT SIZE=2>    </FONT> Person p = <B>new</B> Person();
<FONT SIZE=2>    </FONT>   p.setName("Schneider");
<FONT SIZE=2>    </FONT>   p.setVorname("Rosemarie");
<FONT SIZE=2>    </FONT>   p.setAge(37);
<FONT SIZE=2>   5</FONT> 
<FONT SIZE=2>    </FONT> Person hans = <B>new</B> Person();
<FONT SIZE=2>    </FONT>   hans.setName("Peter");
<FONT SIZE=2>    </FONT>   hans.setVorname("Hans");
<FONT SIZE=2>    </FONT>   hans.setAge(37);
<FONT SIZE=2>  10</FONT> 
<FONT SIZE=2>    </FONT> Vector transferringObjects = <B>new</B> Vector();
<FONT SIZE=2>    </FONT>   transferringObjects.addElement(p);
<FONT SIZE=2>    </FONT>   transferringObjects.addElement(hans);
<FONT SIZE=2>    </FONT> 
<FONT SIZE=2>  15</FONT> <B>new</B> BulkObjectPusher(transferringObjects).addObserver(<B>this</B>);</DIV><BR>
<BR>
Die Klassen der OOP Bibliothek sind in ihrer Anwendung sehr einfach.
Der in [Listing <A HREF="#oopdev:bspa:bop">2</A>] gedruckte Code f�hrt den Transfer
der Daten in Zeile 15 durch. Wie zu sehen ist, wird die Klasse ohne
Zuweisung initialisiert. Eine Zuweisung auf eine lokal verf�gbare
Variable ist nicht notwendig. Durch den an die Klasse
angeschlossenen <I><FONT COLOR=maroon>Observer</FONT></I><SUP><A NAME="text68" HREF="#note68">5</A></SUP> ist es m�glich, �ber das Ende der
Daten�bertragung informiert zu werden. Es ist weiterhin zu erkennen,
dass dem Objekt keine Zieladresse �bergeben wurde. Das ist ebenfalls
nicht notwendig, da die Bibliothek in der Lage ist, ihren
Kommunikationspartner selbstst�ndig zu lokalisieren.<BR>
<BR>
Um auf dem entfernten Ger�t Daten empfangen zu k�nnen muss der
<TT>ObjectReceiver</TT> instanziiert werden. Er ist, ebenso wie die
Klassen <TT>ObjectPusher</TT> und <TT>BulkObjectPusher</TT> nicht
blockierend implementiert. 
<A NAME="@default142"></A>
<DIV CLASS="center">Listing&nbsp;3: <A NAME="oopdev:bspa:or"></A>Verwendung von
 <TT>ObjectReceiver</TT></DIV><BR>
<DIV CLASS="lstlisting"><FONT SIZE=2>    </FONT> Vector receivedObjects = <B>new</B> Vector();
<FONT SIZE=2>    </FONT> 
<FONT SIZE=2>    </FONT> <B>new</B> ObjectReceiver(receivedObjects);</DIV><BR>
<BR>
Der vorgestellte Code in [Listing <A HREF="#oopdev:bspa:or">3</A>] empf�ngt die
�bertragenen Objekte und speichert sie in den Vector
<TT>receivedObjects</TT>, aus dem die empfangenen Daten zu einem
sp�teren Zeitpunkt wieder ausgelesen und weiterverabeitet werden
k�nnen.<BR>
<BR>
Damit dies alles m�glich ist, muss das zu �bertragende Objekt
lediglich das Interface <TT>IObexObjectPassing</TT> implementieren. Ein
partieller Ausschnitt der Implementierung des <TT>Person</TT> Objekts
ist in [Listing <A HREF="#oopdev:bspa:ioop">4</A>] dargestellt. Die restlichen
Methoden sind ausschliesslich Accessor/Mutator Methoden des Objekts.<BR>
<BR>
<A NAME="@default143"></A>
<DIV CLASS="center">Listing&nbsp;4: <A NAME="oopdev:bspa:ioop"></A>Implementierung von <TT>IObexObjectPassing</TT></DIV><BR>
<DIV CLASS="lstlisting"><FONT SIZE=2>    </FONT> <B>public</B> <B>byte</B>[] getAsByteArray()
<FONT SIZE=2>    </FONT> {
<FONT SIZE=2>    </FONT>     bout = <B>new</B> ByteArrayOutputStream();
<FONT SIZE=2>    </FONT>     dout = <B>new</B> DataOutputStream( bout );
<FONT SIZE=2>   5</FONT>     <B>byte</B>[] ret = <B>null</B>;
<FONT SIZE=2>    </FONT> 
<FONT SIZE=2>    </FONT>     <B>try</B>
<FONT SIZE=2>    </FONT>     {
<FONT SIZE=2>    </FONT>         <EM>/* Write values */</EM>
<FONT SIZE=2>  10</FONT>         dout.writeUTF(name);
<FONT SIZE=2>    </FONT>         dout.writeUTF(vorname);
<FONT SIZE=2>    </FONT>         dout.writeInt(age);
<FONT SIZE=2>    </FONT>         dout.flush();
<FONT SIZE=2>    </FONT> 
<FONT SIZE=2>  15</FONT>         <EM>/* do temp copy so we can close
<FONT SIZE=2>    </FONT>          * the writers
<FONT SIZE=2>    </FONT>          */</EM>
<FONT SIZE=2>    </FONT>         ret = bout.toByteArray();
<FONT SIZE=2>    </FONT>         dout.close();
<FONT SIZE=2>  20</FONT>         bout.close();
<FONT SIZE=2>    </FONT>     }
<FONT SIZE=2>    </FONT>     <B>catch</B> (IOException ex)
<FONT SIZE=2>    </FONT>     {
<FONT SIZE=2>    </FONT>         ex.printStackTrace();
<FONT SIZE=2>  25</FONT>     }
<FONT SIZE=2>    </FONT> 
<FONT SIZE=2>    </FONT>     <B>return</B> ret;
<FONT SIZE=2>    </FONT> }
<FONT SIZE=2>    </FONT> 
<FONT SIZE=2>  30</FONT> <B>public</B> <B>void</B> setObjectData(<B>byte</B>[] ba)
<FONT SIZE=2>    </FONT> {
<FONT SIZE=2>    </FONT>     bin = <B>new</B> ByteArrayInputStream(ba);
<FONT SIZE=2>    </FONT>     din = <B>new</B> DataInputStream(bin);
<FONT SIZE=2>    </FONT>     <B>try</B>
<FONT SIZE=2>  35</FONT>     {
<FONT SIZE=2>    </FONT>         <B>this</B>.name = din.readUTF();
<FONT SIZE=2>    </FONT>         <B>this</B>.vorname = din.readUTF();
<FONT SIZE=2>    </FONT>         <B>this</B>.age = din.readInt();
<FONT SIZE=2>    </FONT> 
<FONT SIZE=2>  40</FONT>         din.close();
<FONT SIZE=2>    </FONT>         bin.close();
<FONT SIZE=2>    </FONT>     }
<FONT SIZE=2>    </FONT>     <B>catch</B> (IOException ex)
<FONT SIZE=2>    </FONT>     {
<FONT SIZE=2>  45</FONT>         ex.printStackTrace();
<FONT SIZE=2>    </FONT>     }
<FONT SIZE=2>    </FONT> }</DIV><BR>
<BR>
Die wichtigsten Elemente, des in [Listing <A HREF="#oopdev:bspa:ioop">4</A>]
dargestellten Codes sind die Zeilen 10-12 sowie die Zeilen 36-38. Mit
diesen Zeilen werden die Daten des Objekts in ein Byte-Array
geschrieben (10-12) und k�nnen ebenfalls von einem Byte-Array gelesen
werden (36-38). Dieser Mechanismus ist zur korrekten Funktionsweise der
OOP-Bibliothek notwendig<SUP><A NAME="text69" HREF="#note69">6</A></SUP>.<BR>
<BR>
Der Ablauf der Beispielapplikation ist in
[Abb.: <A HREF="#oopdev:bspa:pics">4.4</A>] dargestellt. Da die Applikation auf zwei
Mobiltelefonen gestartet werden muss, wird im Begleittext das
jeweilige Ger�t mit &gt;&gt;1&lt;&lt; oder &gt;&gt;2&lt;&lt; markiert. Ist keine Markierung
angegeben, so bezieht sich die Anzeige auf beide Telefone.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
 [Auf beiden Telefonen muss zun�chst das
 Programm mittels &#8220;Launch&#8221; gestartet werden.]<BR>
<IMG SRC="ObexObjectPassing023.gif"><BR>

 [Anzeige nach dem Programmstart.]<BR>
<IMG SRC="ObexObjectPassing024.gif"><BR>

 [&gt;&gt;1&lt;&lt; Der Server muss gestartet
 werden.]<BR>
<IMG SRC="ObexObjectPassing025.gif"><BR>
 [&gt;&gt;1&lt;&lt; Der Start
 des Servers muss einmalig best�tigt werden, da ein Zugriff auf das
 Bluetooth API erfolgt.]<BR>
<IMG SRC="ObexObjectPassing026.gif"><BR>

 [&gt;&gt;1&lt;&lt; Die vorhandenen Daten sollen angezeigt
 werden.]<BR>
<IMG SRC="ObexObjectPassing027.gif"><BR>
 [&gt;&gt;1&lt;&lt; Es sind
 keine Daten verf�gbar, mit &#8220;Back&#8221;
 verlassen]<BR>
<IMG SRC="ObexObjectPassing028.gif"><BR>

 [&gt;&gt;2&lt;&lt; Daten sollen �bertragen
 werden.]<BR>
<IMG SRC="ObexObjectPassing029.gif"><BR>
 [&gt;&gt;2&lt;&lt; Zum senden
 &#8220;Send&#8221; w�hlen.]<BR>
<IMG SRC="ObexObjectPassing030.gif"><BR>

 [&gt;&gt;2&lt;&lt; Der Zugriff auf das Bluetooth API muss einmalig
 best�tigt werden.]<BR>
<IMG SRC="ObexObjectPassing031.gif"><BR>

 [&gt;&gt;2&lt;&lt; Die �bertragung wird best�tigt, mit &#8220;Done&#8221;
 verlassen.]<BR>
<IMG SRC="ObexObjectPassing032.gif"><BR>
 
[&gt;&gt;1&lt;&lt; Empfangene Daten k�nnen angezeigt werden.]<BR>
<IMG SRC="ObexObjectPassing033.gif"><BR>

 <DIV CLASS="center">Abbildung 4.4: Ablauf der Beispielapplikation</DIV>
<A NAME="oopdev:bspa:pics"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>

<!--BEGIN NOTES chapter-->
<HR WIDTH="50%" SIZE=1><DL CLASS="list"><DT CLASS="dt-list"><A NAME="note64" HREF="#text64"><FONT SIZE=5>1</FONT></A><DD CLASS="dd-list">Entwicklungsumgebung und Mobility Pack k�nnen unter
 <A HREF="https://www.netbeans.org"><TT>https://www.netbeans.org</TT></A> bezogen werden.
<DT CLASS="dt-list"><A NAME="note65" HREF="#text65"><FONT SIZE=5>2</FONT></A><DD CLASS="dd-list">Siehe <A HREF="https://www.j2mepolish.org/"><TT>https://www.j2mepolish.org/</TT></A>
<DT CLASS="dt-list"><A NAME="note66" HREF="#text66"><FONT SIZE=5>3</FONT></A><DD CLASS="dd-list">Siehe
 <A HREF="https://www.j2mepolish.org/docs/install.html#netbeans5"><TT>https://www.j2mepolish.org/docs/install.html#netbeans5</TT></A>
<DT CLASS="dt-list"><A NAME="note67" HREF="#text67"><FONT SIZE=5>4</FONT></A><DD CLASS="dd-list">Eine Einf�hrung in die MIDP
 Entwicklung mit Hilfe des Mobility Packs f�r Netbeans ist unter
 [<A HREF="#nb:mpqsg"><CITE>Net06</CITE></A>] zu finden.
<DT CLASS="dt-list"><A NAME="note68" HREF="#text68"><FONT SIZE=5>5</FONT></A><DD CLASS="dd-list">Siehe
 [Kapitel <A HREF="#impl:design:dimpl">3.2.2</A>]
<DT CLASS="dt-list"><A NAME="note69" HREF="#text69"><FONT SIZE=5>6</FONT></A><DD CLASS="dd-list">Siehe [Kapitel <A HREF="#impl:dem">3.3</A>]
</DL>
<!--END NOTES-->
<!--TOC chapter Konklusion und Ausblick-->

<H1 CLASS="chapter"><A NAME="htoc60">Kapitel&nbsp;5</A>&nbsp;&nbsp;Konklusion und Ausblick</H1><!--SEC END -->

<A NAME="konkl"></A>
Durch den Einsatz der OOP Bibliothek wird die Entwicklung von
Applikationen, die Daten �ber eine Bluetooth Funkstrecke versenden
m�chten, wesentlich vereinfacht. Durch die Implementierung des von
der Bibliothek vorgegebenen Interfaces erh�lt man zus�tzlich die
M�glichkeit, die erstellten Objekte direkt mit dem RMS zu verwenden,
was den Zugewinn durch den Einsatz der Bibliothek erh�ht. <BR>
<BR>
Die notwendigen Zeilen Code, die normalerweise zum Verbindungsauf- und
-abbau geschrieben werden m�ssten, sinken durch den Einsatz der
Bibliothek auf ein Minimum. Mit welchem minimalen Aufwand eine
Applikation erstellt werden kann, die in der Lage ist Daten zu einem
entfernten Endger�t zu senden, ist in Kapitel <A HREF="#oopdev">4</A>
demonstriert worden. Wieviel Aufwand es bedeuten w�rde die selbe
Applikation mit Hilfe des Peer2Me Frameworks zu entwickeln, konnte auf
Grund der sp�ten Entdeckung, nicht evaluiert werden.<BR>
<BR>
Beim Umgang mit der Bluetooth-Technologie war festzustellen, dass sich
die Anwendungsentwicklung f�r mobile Endger�te, teilweise
problematisch darstellt. So ist bspw. bei vielen Mobiltelefonen der
JSR-82 lediglich teilweise implementiert, was zur Folge hat, dass die
OBEX Bibliotheken nachger�stet werden m�ssen, was auf Kosten der
geringen Speicherkapazit�t der Ger�te teuer erkauft werden muss. Die
strikten Sicherheitsmechanismen der J2ME Architektur legen einem in
diesem Fall ebenfalls Steine in den Weg. So ist eine globale
Nachr�stung der OBEX-Funktionalit�t, auf Grund des Verbots der
nachtr�glichen Installation externer Bibliotheken, nicht m�glich. Als
weiteres Problem stellt sich die Vielzahl verf�gbarer Bluetooth-Stacks
dar. M�chte man eine Applikation f�r ein Desktop-System schreiben, so
muss f�r fast jeden verf�gbaren Bluetooth-Stack eine entsprechende
Bin�rdatei zur Verf�gung gestellt werden.<BR>
<BR>
Die Sicherheit der Bluetooth-Architektur sollte jedoch nicht
�bersch�tzt werden. Die Behauptung, dass sich Bluetooth wegen seiner
kurzen Distanz nur schwer abh�ren lasse, konnte erfolgreich widerlegt
werden. Mit Hilfe spezieller Richtantennen ist es m�glich, Ger�te aus
Entfernungen bis zu 1.6 Km anzusteuern und erfolgreich auszusp�hen
[<A HREF="#wired:btsec"><CITE>Zet04</CITE></A><CITE>, S. 2</CITE>]. Allein durch die Tatsache, dass es sich bei
Bluetooth um eine Kurzstreckenfunktechnologie handelt, sollte man sich
demnach nicht in falscher Sicherheit wiegen.<BR>
<BR>
Bez�glich der Sicherheit der Bibliothek gilt es zu pr�fen, ob sich im
konkreten Einsatz, der OBEX Header manipulieren l�sst, sodass das
Ger�t dazu veranlasst werden kann, eine nicht den Daten zugeh�rige
Klasse zu laden.<BR>
<BR>
Durch die Transportprotokollunabh�ngigkeit des OBEX Protokolls l�sst
sich die Bibliothek leicht auf andere Transportprotokolle portieren.
Eine Weiterentwicklung der Bibliothek, die zus�tzliche
Transportprotokolle unterst�tzt, w�re in diesem Zusammenhang
vorstellbar. So w�re es in Zukunft denkbar, dass die eingangs erw�hnte
&#8222;Einkaufszettel&#8220;-Applikation das mobile Endger�t �ber Bluetooth und
den vorhandenen Desktop-Computer �ber TCP/IP ansteuert.
<BR>
<BR>

<!--TOC chapter Entwicklungsumgebung-->

<H1 CLASS="chapter"><A NAME="htoc61">Anhang&nbsp;A</A>&nbsp;&nbsp;Entwicklungsumgebung</H1><!--SEC END -->

<A NAME="de"></A>
Im Folgenden wird beschrieben, wie sich die entwickelte Bibliothek
innerhalb der Netbeans IDE einsetzen l�sst. Die Beschreibung umfasst
dabei die Erzeugung eines neuen Projektes welches die Bibliothek
verwendet, sowie die notwendigen Schritte um die Beispielapplikation
in Betrieb zu nehmen.<BR>
<BR>
<!--TOC section Anlegen eines J2ME Projekts mit OOP-->

<H2 CLASS="section"><A NAME="htoc62">A.1</A>&nbsp;&nbsp;Anlegen eines J2ME Projekts mit OOP</H2><!--SEC END -->

<A NAME="de:oopAlg"></A>
<A NAME="@default144"></A>
<A NAME="@default145"></A>
Nachdem die IDE gestartet ist, kann mit der Tastenkombination
&gt;&gt;<SPAN STYLE="font-variant:small-caps">Strg+Shift+n</SPAN>&lt;&lt;  ein neues Projekt er�ffnet werden. Man w�hlt nun,
wie in [Abb.: <A HREF="#de:1">A.1</A>] gezeigt, &#8222;Mobile&#8220;&rarr;&#8222;Mobile Application&#8220;
und f�hrt mit dem &#8222;Next&#8220; Button fort.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing034.gif"><DIV CLASS="center">Abbildung A.1: Neue Applikation anlegen</DIV><A NAME="de:1"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Als n�chstes zeigt sich einem der Dialog aus [Abb.: <A HREF="#de:2">A.2</A>], in dem
man einen Projektordner, sowie einen Namen f�r das Projekt
spezifiziert. Die Erzeugung des &#8222;Hello MIDlets&#8220; kann deaktiviert
werden, bleibt jedoch in diesem Beispiel aktiv.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing035.gif"><DIV CLASS="center">Abbildung A.2: Applikation benennen</DIV><A NAME="de:2"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Der Dialog kann jetzt mit einem Klick auf &#8222;Finish&#8220; beendet
werden. Anschliessend zeigt sich einem [Abb.: <A HREF="#de:3">A.3</A>].
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing036.gif"><DIV CLASS="center">Abbildung A.3: Arbeitsplatz nach anlegen der Applikation</DIV><A NAME="de:3"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Nachdem die Applikation erzeugt wurde, wird gem�ss der
Projektorganisation aus [Kapitel <A HREF="#oopdev:po">4.2</A>] eine Entit�sbibliothek
erzeugt. Durch die Tastenkombination &gt;&gt;<SPAN STYLE="font-variant:small-caps">Strg+Shift+n</SPAN>&lt;&lt;  wird erneut der
&#8222;New Project&#8220; Dialog ge�ffnet. Diesmal f�llt die Auswahl jedoch auf
&#8222;Mobil&#8220;&rarr;&#8222;Mobile Class Library&#8220;, wie in
[Abb.: <A HREF="#de:4">A.4</A>] zu sehen ist.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing037.gif"><DIV CLASS="center">Abbildung A.4: Entit�tsbibliothek anlegen</DIV><A NAME="de:4"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Man spezifiziert f�r die Bibliothek, wie in [Abb.: <A HREF="#de:5">A.5</A>] gezeigt,
ebenfalls einen Namen und einen Projektordner und beendet den Dialog
mit einem Klick auf &#8222;Finish&#8220;.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing038.gif"><DIV CLASS="center">Abbildung A.5: Entit�tsbibliothek benennen</DIV><A NAME="de:5"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Der vorzufindene Arbeitsplatz sieht nun aus wie in [Abb.: <A HREF="#de:6">A.6</A>]
dargestellt. 
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing039.gif"><DIV CLASS="center">Abbildung A.6: Arbeitsplatz nach anlegen der Entit�tsbibliothek</DIV><A NAME="de:6"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Als n�chstes muss die OOP Bibliothek Netbeans bekannt gemacht
werden. Dies geschieht �ber den &#8222;Library Manager&#8220; der durch die
Tastenkombination &gt;&gt;<SPAN STYLE="font-variant:small-caps">Alt+t+l</SPAN>&lt;&lt;  ge�ffnet werden kann. In dem folgenden
Dialog selektiert man &#8222;Mobile Libraries&#8220;, und klickt auf &#8222;New
Library&#8220;, woraufhin ein neuer Dialog erscheint, in dem der Name der
Bibliothek eingetragen werden muss (siehe [Abb.: <A HREF="#de:7">A.7</A>]). 
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing040.gif"><DIV CLASS="center">Abbildung A.7: Erzeugen einer neuen Bibliothek
 (&#8222;Library Manager&#8220;)</DIV><A NAME="de:7"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Ist dieser Schritt abgeschlossen muss der Bibliotheksbezeichnung noch
ein Java-Archiv (JAR) hinzugef�gt werden. Dies geschieht durch einen
Klick auf &#8222;Add JAR&#8220;. In dem aufkommenden Dialog muss nun die
JAR-Datei der OOP Bibliothek von dem lokalen Dateisystem gew�hlt
werden (ObexObjectPassing.jar). Ist dieser Schritt abgeschlossen,
zeigt sich einem [Abb.: <A HREF="#de:8">A.8</A>]
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing041.gif"><DIV CLASS="center">Abbildung A.8: JAR Datei selektiert und hinzugef�gt</DIV><A NAME="de:8"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Die Bibliothek ist Netbeans nun bekannt und kann in den der IDE
bekannten Projekten verwendet werden. Die Bibliothek muss zun�chst dem
Entit�tsprojekt zugeordnet werden. Dazu klickt man mit der rechten
Maustaste auf das Entit�tsprojekt, und selektiert, wie in
[Abb.: <A HREF="#de:9">A.9</A>] gezeigt &#8222;Libraries &amp; Resources&#8220;. Dort ordnet man
die Bibliothek mit einem Klick auf &#8222;Add Library&#8220; dem Projekt zu.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing042.gif"><DIV CLASS="center">Abbildung A.9: Bibliothek zum
 Entit�tsprojekt hinzuf�gen</DIV><A NAME="de:9"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Nachdem die Bibliothek mit einem Klick auf &#8222;Add Library&#8220; und &#8222;Ok&#8220;
hinzugef�gt wurde, muss die Entit�tsbibliothek dem J2ME Projekt
zugeordnet werden. Dazu w�hlt man , nach einem Rechtsklick auf das
J2ME Projekt &#8222;Properties&#8220;&rarr;&#8222;Libraries &amp;
Resources&#8220;. Das Entit�tsprojekt kann nun, mit einem Klick auf &#8222;Add
Project&#8220; vom lokalen Dateisystem gew�hlt werden (siehe [Abb.: <A HREF="#de:10">A.10</A>]).
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing043.gif"><DIV CLASS="center">Abbildung A.10: Entit�tsprojekt
 der Applikation hinzuf�gen</DIV><A NAME="de:10"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Damit die OOP Bibliothek auch in der J2ME-Anwendung zur Verf�gung
steht muss sie, nach dem obligatorischen Rechtsklick, und der Wahl von
&#8222;Properties&#8220;&rarr;&#8222;Libraries &amp; Resources&#8220;, mit der
Selektion von &#8222;Add Library&#8220; hinzugef�gt werden.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><IMG SRC="ObexObjectPassing044.gif"><DIV CLASS="center">Abbildung A.11: OOP Bibliothek der
 Applikation hinzuf�gen</DIV><A NAME="de:11"></A><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE>
Nach einem Klick auf &#8222;Add Library&#8220;&rarr;&#8222;Ok&#8220; ist die
Bibliothek korrekt in das Projekt eingebunden worden. Ab diesem
Zeitpunkt kann entwickelt werden.<BR>
<BR>
<!--TOC section Beispielapplikation in Betrieb nehmen-->

<H2 CLASS="section"><A NAME="htoc63">A.2</A>&nbsp;&nbsp;Beispielapplikation in Betrieb nehmen</H2><!--SEC END -->

<A NAME="de:oopIOOP"></A>
<A NAME="@default146"></A>
Um die Beispielapplikation in Betrieb zu nehmen, m�ssen die Dateien
<I><FONT COLOR=maroon>IOOP2.zip</FONT></I>, <I><FONT COLOR=maroon>IOOPEntityLib.zip</FONT></I>,
<I><FONT COLOR=maroon>ObexObjectPassingSrc.zip</FONT></I> und <I><FONT COLOR=maroon>avetanaObex.jar</FONT></I> auf
dem lokalen Dateisystem &ndash; mit Ausnahme der JAR Datei &ndash; entpackt
werden.<BR>
<BR>
Ist dies geschehen, muss die avetanaOBEX Bibliothek unter dem Namen
&#8222;avetanaOBEX&#8220; im &#8222;Library Manager&#8220; der IDE unter &#8222;Mobile
Libraries&#8220; registriert werden. Der Vorgang ist in [Abb.: <A HREF="#de:7">A.7</A>]
und [Abb.: <A HREF="#de:8">A.8</A>] bebildert und wird in [Kapitel <A HREF="#de:oopAlg">A.1</A>] f�r
ein neues Projekt beschrieben. Ist der Import der Bibliothek
abgeschlossen, k�nnen die drei Projektordner mit der Tastenkombination
&gt;&gt;<SPAN STYLE="font-variant:small-caps">Strg+Shift+o</SPAN>&lt;&lt;  ge�ffnet, und der IDE hinzugefuegt werden. Hat alles
geklappt muss ggf. das &#8222;IOOP&#8220; Projekt mit der rechten Maustaste als
&#8222;Set Main Project&#8220; markiert werden. Die Applikation kann
anschliessend durch einen Tastendruck auf &gt;&gt;<SPAN STYLE="font-variant:small-caps">F6</SPAN>&lt;&lt;  augef�hrt werden. Es
ist zu beachten, dass zur korrekten Demonstration, wie sie in
[Abb.: <A HREF="#oopdev:bspa:pics">4.4</A>] dargestellt wird, das Projekt zweimal
gestartet werden muss.<BR>
<BR>

<!--TOC chapter Glossar und Abk�rzungsverzeichnis-->

<H1 CLASS="chapter"><A NAME="htoc64">Anhang&nbsp;B</A>&nbsp;&nbsp;Glossar und Abk�rzungsverzeichnis</H1><!--SEC END -->

<BR>

<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description"><B><FONT SIZE=5>A</FONT></B><DD CLASS="dd-description"><BR>
<BR>
<DT CLASS="dt-description"><B>ACL, S. 9
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Asynchronous Connection-Oriented (logical transport)</FONT></I> <DT CLASS="dt-description"><B>ACL-C, S. 10
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>ACL Control</FONT></I> <DT CLASS="dt-description"><B>ACL-U, S. 10
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>User Asynchronous/Isochronous</FONT></I> <DT CLASS="dt-description"><B>AFH, S. 7
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Adaptive Frequency-Hopping spread spectrum</FONT></I>, Verfahren zur Reduktion der St�ranf�lligkeit gegen�ber anderen Funktechnologien (z.+.1667emB. WLAN) <DT CLASS="dt-description"><B>AMS, S. 45
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Application Management Software</FONT></I> <DT CLASS="dt-description"><B>API, S. 16
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Application Programming Interface</FONT></I> <DT CLASS="dt-description"><B>ARQ, S. 10
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Acknowledgement/Repeat Request</FONT></I> <DT CLASS="dt-description"><B>ASB, S. 9
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Active Slave Broadcast (logical transport)</FONT></I> <BR>
<BR>
<BR>
<BR>
<BR>
<DT CLASS="dt-description"><B><FONT SIZE=5>B</FONT></B><DD CLASS="dd-description"><BR>
<BR>
<DT CLASS="dt-description"><B>BCC, S. 23
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Bluetooth Control Center</FONT></I>, Zentrale Anlaufstelle welche die Bluetooth-Einstellungen des lokalen Ger�ts verwaltet. <DT CLASS="dt-description"><B>BD_ADDR, S. 11
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Bluetooth Device Address</FONT></I> <BR>
<BR>
<BR>
<BR>
<BR>
<DT CLASS="dt-description"><B><FONT SIZE=5>C</FONT></B><DD CLASS="dd-description"><BR>
<BR>
<DT CLASS="dt-description"><B>CDC, S. 16
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Connected Device Configuration</FONT></I> <DT CLASS="dt-description"><B>CID, S. 11
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Channel Identifier</FONT></I> <DT CLASS="dt-description"><B>CLDC, S. 15
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Connected Limited Device Configuration</FONT></I>, Grundlage von J2ME. Geht aus den JSRs 30 und 139 hervor (Version 1.0/1.1) <DT CLASS="dt-description"><B>CLDC HotSpot Implementation, S. 15
</B><DD CLASS="dd-description"> Nachfolgeimplementierung der KVM mit verbesserter Performanz (8-10x schneller) <BR>
<BR>
<BR>
<BR>
<BR>
<DT CLASS="dt-description"><B><FONT SIZE=5>D</FONT></B><DD CLASS="dd-description"><BR>
<BR>
<DT CLASS="dt-description"><B>Discovery, S. 25
</B><DD CLASS="dd-description"> dt. Entdeckung; bezeichnet den Prozess der es zwei Bluetooth-Ger�ten erm�glicht sich gegenseitig zu lokalisieren. <BR>
<BR>
<BR>
<BR>
<BR>
<DT CLASS="dt-description"><B><FONT SIZE=5>E</FONT></B><DD CLASS="dd-description"><BR>
<BR>
<DT CLASS="dt-description"><B>EDR, S. 7
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Enhanced Data Rate</FONT></I> <DT CLASS="dt-description"><B>EJB, S. 31
</B><DD CLASS="dd-description"> Enterprise JavaBeans <DT CLASS="dt-description"><B>eSCO, S. 9
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Extended Synchronous Connection-Oriented (logical transport)</FONT></I> <DT CLASS="dt-description"><B>eSCO-S, S. 10
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>User Extended Synchronous</FONT></I> <BR>
<BR>
<BR>
<BR>
<BR>
<DT CLASS="dt-description"><B><FONT SIZE=5>F</FONT></B><DD CLASS="dd-description"><BR>
<BR>
<DT CLASS="dt-description"><B>FTP, S. 9
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>File Transfer Protocol</FONT></I> <BR>
<BR>
<BR>
<BR>
<BR>
<DT CLASS="dt-description"><B><FONT SIZE=5>G</FONT></B><DD CLASS="dd-description"><BR>
<BR>
<DT CLASS="dt-description"><B>GAP, S. 12
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Generic Access Profile</FONT></I> <DT CLASS="dt-description"><B>GCF, S. 16
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Generic Connection Framework</FONT></I>, offeriert die M�glichkeit, auf Ein- und Ausgabeoperationen sowie Netzwerkressourcen zuzugreifen. <DT CLASS="dt-description"><B>GFSK, S. 6
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Gaussian Frequency Shift Keying</FONT></I>, Bei Bluetooth oder DECT Technologie eingesetztes Modulationsverfahren. <DT CLASS="dt-description"><B>GIAC, S. 13
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>General/Unlimited Inquiry Access Code</FONT></I> <DT CLASS="dt-description"><B>GOEP, S. 29
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Generic Object Exchange Profile</FONT></I>, Bluetooth-Profil welches das OBEX Protokoll implementiert. <BR>
<BR>
<BR>
<BR>
<BR>
<DT CLASS="dt-description"><B><FONT SIZE=5>H</FONT></B><DD CLASS="dd-description"><BR>
<BR>
<DT CLASS="dt-description"><B>HCI, S. 11
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Host Controller Interface</FONT></I>, befindet sich zwischen logischem und L2CAP-Layer und stellt eine einheitliche Schnittstelle zum Bluetooth-Controller dar. <DT CLASS="dt-description"><B>HTTP, S. 28
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Hypertext Transfer Protocol</FONT></I> <BR>
<BR>
<BR>
<BR>
<BR>
<DT CLASS="dt-description"><B><FONT SIZE=5>I</FONT></B><DD CLASS="dd-description"><BR>
<BR>
<DT CLASS="dt-description"><B>ID, S. 19
</B><DD CLASS="dd-description"> Identifikationsnummer <DT CLASS="dt-description"><B>IDE, S. 48
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Integrated Development Environment</FONT></I> <DT CLASS="dt-description"><B>ISM, S. 6
</B><DD CLASS="dd-description"> Industrial, Scientific, and Medical Band <BR>
<BR>
<BR>
<BR>
<BR>
<DT CLASS="dt-description"><B><FONT SIZE=5>J</FONT></B><DD CLASS="dd-description"><BR>
<BR>
<DT CLASS="dt-description"><B>J2ME , S. 14
</B><DD CLASS="dd-description"> Java 2 Platform, Micro Edition <DT CLASS="dt-description"><B>JABWT, S. 21
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Java API for Bluetooth Wireless Technology</FONT></I> <DT CLASS="dt-description"><B>JSR, S. 15
</B><DD CLASS="dd-description"> Java Specification Request <BR>
<BR>
<BR>
<BR>
<BR>
<DT CLASS="dt-description"><B><FONT SIZE=5>K</FONT></B><DD CLASS="dd-description"><BR>
<BR>
<DT CLASS="dt-description"><B>KVM, S. 15
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>K Virtual Machine</FONT></I>, manchmal auch Kilobyte Virtual Machine Virtuelle Maschine, die mit sehr geringen Hardwareanforderungen auskommt. <BR>
<BR>
<BR>
<BR>
<BR>
<DT CLASS="dt-description"><B><FONT SIZE=5>L</FONT></B><DD CLASS="dd-description"><BR>
<BR>
<DT CLASS="dt-description"><B>L2CAP, S. 11
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Logical Link Control and Adaption Protocol</FONT></I> <DT CLASS="dt-description"><B>LC, S. 10
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Link Control</FONT></I> <DT CLASS="dt-description"><B>LIAC, S. 13
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Limited Dedicated Inquiry Access Code</FONT></I> <DT CLASS="dt-description"><B>LLID, S. 10
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Logical Link Identifier</FONT></I>, Feld im Basisband-Paketkopf um die logische Verbindung zu identifizieren <DT CLASS="dt-description"><B>LM, S. 10
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Link Manager</FONT></I>, verantwortlich f�r die Erzeugung, Modifikation und Freigabe logischer Verbindungen. <DT CLASS="dt-description"><B>LMP, S. 10
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Link Manager Protocol</FONT></I>, Protokoll, mit dessen Hilfe Kontrollinformationen zwischen den <I><FONT COLOR=maroon>Link Manager</FONT></I> Instanzen zweier Endger�te ausgetauscht werden k�nnen. <BR>
<BR>
<BR>
<BR>
<BR>
<DT CLASS="dt-description"><B><FONT SIZE=5>M</FONT></B><DD CLASS="dd-description"><BR>
<BR>
<DT CLASS="dt-description"><B>MID, S. 18
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Mobile Information Device</FONT></I> <DT CLASS="dt-description"><B>MIDlet, S. 18
</B><DD CLASS="dd-description"> Programm, dass auf einem MID ausgef�hrt werden kann. <DT CLASS="dt-description"><B>MIDP, S. 18
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Mobile Information Device Profile</FONT></I> <DT CLASS="dt-description"><B>MTU, S. 24
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Maximum Transfer Unit</FONT></I>, Anzahl an Daten die unfragmentiert in einem Paket �bertragen werden k�nnen. <BR>
<BR>
<BR>
<BR>
<BR>
<DT CLASS="dt-description"><B><FONT SIZE=5>O</FONT></B><DD CLASS="dd-description"><BR>
<BR>
<DT CLASS="dt-description"><B>OBEX, S. 22
</B><DD CLASS="dd-description"> OBject EXchange (Protocol) <DT CLASS="dt-description"><B>OEM, S. 22
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Original Equipment Manufacturer</FONT></I> <DT CLASS="dt-description"><B>OOP, S. 32
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>OBEX Object Passing</FONT></I> <BR>
<BR>
<BR>
<BR>
<BR>
<DT CLASS="dt-description"><B><FONT SIZE=5>P</FONT></B><DD CLASS="dd-description"><BR>
<BR>
<DT CLASS="dt-description"><B>PDA, S. 15
</B><DD CLASS="dd-description"> Personal Digital Assistant, kleiner Computer, der typischerweise in einer Handfl�che Platz findet. <DT CLASS="dt-description"><B>PSB, S. 9
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Parked Slave Broadcast (logical transport)</FONT></I> <BR>
<BR>
<BR>
<BR>
<BR>
<DT CLASS="dt-description"><B><FONT SIZE=5>R</FONT></B><DD CLASS="dd-description"><BR>
<BR>
<DT CLASS="dt-description"><B>RAM, S. 22
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Random Access Memory</FONT></I> <DT CLASS="dt-description"><B>RAND, S. 11
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Pseudo-Random-Number</FONT></I>, Pseudozufallszahl <DT CLASS="dt-description"><B>RFCOMM, S. 27
</B><DD CLASS="dd-description"> Emulation mehrerer Serieller RS-232 Ports zwischen zwei Bluetooth-Ger�ten <DT CLASS="dt-description"><B>RMI OP, S. 31
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>RMI Optional Package</FONT></I> <DT CLASS="dt-description"><B>RMS, S. 19
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Record Management System</FONT></I>, vom MIDP spezifizierter Mechanismus zur persistenten Speicherung von Daten <DT CLASS="dt-description"><B>ROM, S. 22
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Read Only Memory</FONT></I> <DT CLASS="dt-description"><B>RSSI, S. 7
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Received Signal Strength Indicator</FONT></I> <BR>
<BR>
<BR>
<BR>
<BR>
<DT CLASS="dt-description"><B><FONT SIZE=5>S</FONT></B><DD CLASS="dd-description"><BR>
<BR>
<DT CLASS="dt-description"><B>SCO, S. 9
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Synchronous Connection-Oriented (logical transport)</FONT></I> <DT CLASS="dt-description"><B>SCO-S, S. 10
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>User Synchronous</FONT></I> <DT CLASS="dt-description"><B>SDDB, S. 25
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Service Discovery Database</FONT></I> <DT CLASS="dt-description"><B>SDP, S. 22
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Service Discovery Protocol</FONT></I> <DT CLASS="dt-description"><B>SDU, S. 11
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Service Data Units</FONT></I> <DT CLASS="dt-description"><B>SPP, S. 27
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Serial Port Profile</FONT></I> <BR>
<BR>
<BR>
<BR>
<BR>
<DT CLASS="dt-description"><B><FONT SIZE=5>T</FONT></B><DD CLASS="dd-description"><BR>
<BR>
<DT CLASS="dt-description"><B>TCK, S. 22
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Technology Compatibility Kits</FONT></I>, Test-Suite die eine korrekte Implementierung der Spezifikation �berpr�fen kann. <DT CLASS="dt-description"><B>TCP/IP, S. 35
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Transmission Control Protocol/Internet Protocol</FONT></I> <BR>
<BR>
<BR>
<BR>
<BR>
<DT CLASS="dt-description"><B><FONT SIZE=5>U</FONT></B><DD CLASS="dd-description"><BR>
<BR>
<DT CLASS="dt-description"><B>URL, S. 27
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Uniform Resource Locator</FONT></I>, einheitliche Ortsangabe f�r Ressourcen. <BR>
<BR>
<BR>
<BR>
<BR>
<DT CLASS="dt-description"><B><FONT SIZE=5>V</FONT></B><DD CLASS="dd-description"><BR>
<BR>
<DT CLASS="dt-description"><B>VM, S. 14
</B><DD CLASS="dd-description"> Virtual Machine, Programm, das f�r die entsprechende Plattform �bersetzten Bytecode interpretiert. <BR>
<BR>
<BR>
<BR>
<BR>
<DT CLASS="dt-description"><B><FONT SIZE=5>W</FONT></B><DD CLASS="dd-description"><BR>
<BR>
<DT CLASS="dt-description"><B>WLAN, S. 7
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Wireless Local Area Network</FONT></I> <DT CLASS="dt-description"><B>WTK, S. 32
</B><DD CLASS="dd-description"> <I><FONT COLOR=maroon>Wireless Toolkit</FONT></I>, Ein Set an Emulatoren und zugeh�rigen Bibliotheken, welche die Entwicklung von Applikationen f�r mobile Endger�te erm�glicht. </DL>







<!--TOC chapter Literatur-->

<H1 CLASS="chapter">Literatur</H1><!--SEC END -->
<DL CLASS="list" COMPACT="compact"><DT CLASS="dt-list"><A NAME="pw:hci"><FONT COLOR=purple>[Ano06]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Anonymous</SPAN>.
<EM>HCI Layer Tutorial</EM>.<BR>
<A HREF="https://www.palowireless.com/infotooth/tutorial/hci.asp">https://www.palowireless.com/</A>.
Jan. 2006<BR>
<BR>
<DT CLASS="dt-list"><A NAME="bl:ldswt"><FONT COLOR=purple>[Bal00]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Balzert</SPAN>, Helmut:
<EM>Lehrbuch der Software-Technik</EM>. Bd.&nbsp;1.
2. Auflage.
Spektrum, Akad. Verl., 2000<BR>
<BR>
<DT CLASS="dt-list"><A NAME="sec:dsuj"><FONT COLOR=purple>[Bal05]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Baldwin</SPAN>, Richard&nbsp;G.
<EM>Digital Signatures 101 using Java</EM>.<BR>
<A HREF="https://www.developer.com/java/other/article.php/3469641">https://www.developer.com/</A>.
2005<BR>
<BR>
<DT CLASS="dt-list"><A NAME="bt:gfsk"><FONT COLOR=purple>[Bec05]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Becker</SPAN>, Markus.
<EM>Drahtlose lokale Netze (Ad-hoc / Bluetooth Kommunikation)</EM>.<BR>
<A HREF="https://jerry.c-lab.de/pg-mobileServices/Folien/02_MarkusBecker_adh%
oc-bluetooth.pdf">https://jerry.c-lab.de/</A>.
Jun. 2005<BR>
<BR>
<DT CLASS="dt-list"><A NAME="cbk:bap"><FONT COLOR=purple>[BJJ04]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Bala Kumar</SPAN>, C ; <SPAN STYLE="font-variant:small-caps">J. Kline</SPAN>, Paul ; <SPAN STYLE="font-variant:small-caps">J. Thompson</SPAN>,
 Timothy:
<EM>Bluetooth Application Programming with the Java APIs</EM>.
Morgan-Kaufmann Verlag, 2004<BR>
<BR>
<DT CLASS="dt-list"><A NAME="bt:spez12"><FONT COLOR=purple>[Blu03]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Bluetooth SIG</SPAN>.
<EM>Specification of the Bluetooth System - Wireless connections
 made easy - Version 1.2</EM>.<BR>
<A HREF="https://bluetooth.org/foundry/adopters/document/Bluetooth_Core_Spec%
ification_v1.2">https://bluetooth.org/</A>.
Nov. 2003<BR>
<BR>
<DT CLASS="dt-list"><A NAME="bt:spez20"><FONT COLOR=purple>[Blu04]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Bluetooth SIG</SPAN>.
<EM>Specification of the Bluetooth System - Wireless connections
 made easy - Version 2.0 + EDR</EM>.<BR>
<A HREF="https://www.bluetooth.org/foundry/adopters/document/Core_v2.0_EDR/e%
n/1/Core_v2.0_EDR.zip">https://www.bluetooth.org/</A>.
Nov. 2004<BR>
<BR>
<DT CLASS="dt-list"><A NAME="btsig:goep"><FONT COLOR=purple>[Blu05]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Bluetooth SIG</SPAN>.
<EM>Generic Object Exchange Profile</EM>.<BR>
<A HREF="https://www.bluetooth.org/foundry/adopters/document/10_Goep/">https://www.bluetooth.org/</A>.
Feb. 2005<BR>
<BR>
<DT CLASS="dt-list"><A NAME="btsig:anbb"><FONT COLOR=purple>[Blu06]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Bluetooth SIG</SPAN>.
<EM>Assigned Numbers - Bluetooth Baseband</EM>.<BR>
<A HREF="https://www.bluetooth.org/foundry/assignnumb/document/baseband">https://www.bluetooth.org/</A>.
Mar. 2006<BR>
<BR>
<DT CLASS="dt-list"><A NAME="br:objser"><FONT COLOR=purple>[BSM06]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">B�rki</SPAN>, Reto ; <SPAN STYLE="font-variant:small-caps">Sch�rer</SPAN>, Raffael ; <SPAN STYLE="font-variant:small-caps">M�ller</SPAN>, Martin:
J2ME-Objektserialisierung: Frameworks im Vergleich.
In: <EM>Java Spektrum</EM>
(2006), Feb., Nr. 1, S. 35&ndash;38<BR>
<BR>
<DT CLASS="dt-list"><A NAME="ct:wb"><FONT COLOR=purple>[Bv05]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Bachfeld</SPAN>, Daniel ; <SPAN STYLE="font-variant:small-caps">Zivadinovic</SPAN>, Dusan:
Wurzelbehandlung &ndash; Sicherheitsl�cken bei Bluetooth-Handys.
In: <EM>c't - magazin f�r computer technik</EM>
(2005), Dez., Nr. 26, S. 212&ndash;216<BR>
<BR>
<DT CLASS="dt-list"><A NAME="sm:jsr218"><FONT COLOR=purple>[C</FONT><SUP><FONT COLOR=purple>+</FONT></SUP><FONT COLOR=purple>05]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Courtney</SPAN>, Jon et&nbsp;al.
<EM>Connected Device Configuration (CDC) 1.1</EM>.<BR>
<A HREF="https://jcp.org/en/jsr/detail?id=218">https://jcp.org/</A>.
Aug. 2005<BR>
<BR>
<DT CLASS="dt-list"><A NAME="df:jbht"><FONT COLOR=purple>[Fit05]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Fitton</SPAN>, Dan.
<EM>Java Bluetooth HOWTO</EM>.<BR>
<A HREF="https://www.caside.lancs.ac.uk/java_bt.php">https://www.caside.lancs.ac.uk/</A>.
Dez. 2005<BR>
<BR>
<DT CLASS="dt-list"><A NAME="nokia:jsr75"><FONT COLOR=purple>[For04]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Forum Nokia Global Web Site</SPAN>.
<EM>Introduction To The FileConnection API (With Example) v1.1</EM>.<BR>
<A HREF="https://www.forum.nokia.com/info/sw.nokia.com/id/82644083-2f4b-4775-a%
292-c02d6bf5be57/Introduction_To_The_FileConnection_API_v1_1.zip.html">https://www.forum.nokia.com/</A>.
Nov. 2004<BR>
<BR>
<DT CLASS="dt-list"><A NAME="jfms:kry"><FONT COLOR=purple>[FS06]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Frey</SPAN>, Jens ; <SPAN STYLE="font-variant:small-caps">Schwarz</SPAN>, Matthias.
<EM>Kryptographie - Skriptum zur Vorlesung</EM>.<BR>
<A HREF="https://www.coffeecrew.org/docs/kryptographie.pdf">https://www.coffeecrew.org/</A>.
Mar. 2006<BR>
<BR>
<DT CLASS="dt-list"><A NAME="sg:rms"><FONT COLOR=purple>[Gho06]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Ghosh</SPAN>, Soma.
<EM>J2ME record management store</EM>.<BR>
<A HREF="https://www-128.ibm.com/developerworks/library/wi-rms/">https://www-128.ibm.com/</A>.
Mar. 2006<BR>
<BR>
<DT CLASS="dt-list"><A NAME="lh:macos"><FONT COLOR=purple>[Has06]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Hasik</SPAN>, Lukas.
<EM>Mobility Pack on Mac</EM>.<BR>
<A HREF="https://blogs.sun.com/roller/page/lukas/20051020">https://blogs.sun.com/</A>.
Mar. 2006<BR>
<BR>
<DT CLASS="dt-list"><A NAME="hmhm:vis"><FONT COLOR=purple>[HHT03]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Handy</SPAN>, M. ; <SPAN STYLE="font-variant:small-caps">Haase</SPAN>, M. ; <SPAN STYLE="font-variant:small-caps">Timmermann</SPAN>, D.
<EM>Der Verlust der informationellen Selbstbestimmung?
 Anonymit�tsaspekte bei Bluetooth und WLAN</EM>.<BR>
<A HREF="https://www.vs.inf.ethz.ch/publ/se/handy_iuk2003.pdf">https://www.vs.inf.ethz.ch/</A>.
2003<BR>
<BR>
<DT CLASS="dt-list"><A NAME="mh:btLinux"><FONT COLOR=purple>[Hol03]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Holtmann</SPAN>, Marcel.
<EM>Bluetooth und ISDN unter Linux</EM>.<BR>
<A HREF="https://www.holtmann.org/linux/bluetooth/isdn.html">https://www.holtmann.org/</A>.
Sep. 2003<BR>
<BR>
<DT CLASS="dt-list"><A NAME="ibm:ftobex1"><FONT COLOR=purple>[Hop05a]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Hopkins</SPAN>, Bruce.
<EM>Bluetooth boogies, Part 1: File transfer with JSR-82 and OBEX</EM>.<BR>
<A HREF="https://www-128.ibm.com/developerworks/wireless/library/wi-boogie1/">https://www-128.ibm.com/</A>.
Sep. 2005<BR>
<BR>
<DT CLASS="dt-list"><A NAME="ibm:ftobex2"><FONT COLOR=purple>[Hop05b]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Hopkins</SPAN>, Bruce.
<EM>Bluetooth boogies, Part 2: Creating the Bluetooth Music Store</EM>.<BR>
<A HREF="https://www-128.ibm.com/developerworks/wireless/library/wi-boogie2/">https://www-128.ibm.com/</A>.
Nov. 2005<BR>
<BR>
<DT CLASS="dt-list"><A NAME="jk:rxtx"><FONT COLOR=purple>[Jar05]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Jarvi</SPAN>, Keane.
<EM>RXTX: The Prescription for Transmission</EM>.<BR>
<A HREF="https://users.frii.com/jarvi/rxtx/">https://users.frii.com/</A>.
Jan. 2005<BR>
<BR>
<DT CLASS="dt-list"><A NAME="kjh:bsd"><FONT COLOR=purple>[Kje05]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Kjell</SPAN>, J.H.
<EM>Bluetooth - Part 9: Service Discovery</EM>.<BR>
<A HREF="https://www.vs.inf.ethz.ch/publ/se/handy_iuk2003.pdf">https://www.vs.inf.ethz.ch/</A>.
Apr. 2005<BR>
<BR>
<DT CLASS="dt-list"><A NAME="gk:gtjava"><FONT COLOR=purple>[Kr�00]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Kr�ger</SPAN>, Guido:
<EM>GoTo Java2</EM>.<BR>
2. Auflage.
Addison-Wesley Verlag, 2000. &ndash;
Studentenausgabe<BR>
<BR>
<DT CLASS="dt-list"><A NAME="bc:doc"><FONT COLOR=purple>[Lab06]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Labaye</SPAN>, Denis.
<EM>Bluecove documentation</EM>.<BR>
<A HREF="https://bluecove.sourceforge.net/">https://bluecove.sourceforge.net/</A>.
Jan. 2006<BR>
<BR>
<DT CLASS="dt-list"><A NAME="lcnm:p2me"><FONT COLOR=purple>[LN05]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Lund</SPAN>, Carl-Hendrik&nbsp;W. ; <SPAN STYLE="font-variant:small-caps">Norum</SPAN>, Michael&nbsp;S.:
<EM>The Peer2Me Framework - A Framework for Mobile Collaboration on
 Mobile Phones</EM>, Norwegian University of Science and Technology, Diplomarbeit,
 Jun. 2005<BR>
<BR>
<DT CLASS="dt-list"><A NAME="sm:jsr82"><FONT COLOR=purple>[M</FONT><SUP><FONT COLOR=purple>+</FONT></SUP><FONT COLOR=purple>05]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Milikich</SPAN>, Mike et&nbsp;al.
<EM>JavaAPIs for BluetoothWireless
 Technology (JSR 82) - Specification Version 1.1</EM>.<BR>
<A HREF="https://www.jcp.org/en/jsr/detail?id=82">https://www.jcp.org/</A>.
Sep. 2005<BR>
<BR>
<DT CLASS="dt-list"><A NAME="dell:twp"><FONT COLOR=purple>[MO03]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Mehta</SPAN>, Pratik ; <SPAN STYLE="font-variant:small-caps">O'Connor</SPAN>, Clint H.
<EM>Personal Area Connectivity with BluetoothWireless Technology</EM>.<BR>
<A HREF="https://www1.jp.dell.com/content/topics/global.aspx/vectors/en/2003_%
bluetooth?c=jp&l=jp&s=corp">https://www1.jp.dell.com/</A>.
2003<BR>
<BR>
<DT CLASS="dt-list"><A NAME="nb:mpqsg"><FONT COLOR=purple>[Net06]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Netbeans Community</SPAN>.
<EM>NetBeans Mobility Pack 5.0 Quick Start Guide</EM>.<BR>
<A HREF="https://www.netbeans.org/kb/50/quickstart-mobility.html">https://www.netbeans.org/</A>.
Mar. 2006<BR>
<BR>
<DT CLASS="dt-list"><A NAME="schb:ak"><FONT COLOR=purple>[Sch96]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Schneier</SPAN>, Bruce:
<EM>Angewandte Kryptographie: Protokolle, Algorithmen und
 Sourcecode in C</EM>.
Addison-Wesley, 1996<BR>
<BR>
<DT CLASS="dt-list"><A NAME="ts:obsrv"><FONT COLOR=purple>[Sin01]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Sintes</SPAN>, Tony.
<EM>Speaking on the Observer pattern</EM>.<BR>
<A HREF="https://www.javaworld.com/javaworld/javaqa/2001-05/04-qa-0525-observe%
r.html">https://www.javaworld.com/</A>.
May 2001<BR>
<BR>
<DT CLASS="dt-list"><A NAME="ts:voa"><FONT COLOR=purple>[Sin06]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Sintes</SPAN>, Tony.
<EM>Vector or ArrayList &ndash; which is better and why?</EM><BR>
<A HREF="https://www.javaworld.com/javaworld/javaqa/2001-06/03-qa-0622-vector.%
html">https://www.javaworld.com/</A>.
Jan. 2006<BR>
<BR>
<DT CLASS="dt-list"><A NAME="se:jabt"><FONT COLOR=purple>[Son04]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Sony Ericsson</SPAN>.
<EM>Developing Applications with the Java APIs for
 Bluetooth(JSR-82)</EM>.<BR>
<A HREF="https://www.microjava.com/articles/Bluetooth-jsr-82-training.pdf">https://www.microjava.com/</A>.
Jan. 2004<BR>
<BR>
<DT CLASS="dt-list"><A NAME="sm:j2mebb"><FONT COLOR=purple>[Sun00]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Sun Microsystems, Inc.</SPAN>
<EM>J2ME Building Blocks for Devices</EM>.<BR>
<A HREF="https://java.sun.com/products/cldc/wp/KVMwp.pdf">https://java.sun.com/</A>.
May 2000<BR>
<BR>
<DT CLASS="dt-list"><A NAME="sm:cldchi"><FONT COLOR=purple>[Sun05]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Sun Microsystems, Inc.</SPAN>
<EM>CLDC HotSpot Implementation Virtual Machine</EM>.<BR>
<A HREF="https://java.sun.com/j2me/docs/pdf/CLDC-HI_whitepaper-February_2005%
.pdf">https://java.sun.com/</A>.
Feb. 2005<BR>
<BR>
<DT CLASS="dt-list"><A NAME="sm:j2me"><FONT COLOR=purple>[Sun06]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Sun Microsystems, Inc.</SPAN>
<EM>Java 2 Platform, Micro Edition</EM>.<BR>
<A HREF="https://java.sun.com/j2me/docs/j2me-ds.pdf">https://java.sun.com/</A>.
Mar. 2006<BR>
<BR>
<DT CLASS="dt-list"><A NAME="sm:jsr30"><FONT COLOR=purple>[T</FONT><SUP><FONT COLOR=purple>+</FONT></SUP><FONT COLOR=purple>00]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Taivalsaari</SPAN>, Antero et&nbsp;al.
<EM><BR>
Connected, Limited Device Configuration</EM>.
<A HREF="https://www.jcp.org/en/jsr/detail?id=30">https://www.jcp.org/</A>.
May 2000<BR>
<BR>
<DT CLASS="dt-list"><A NAME="sm:jsr139"><FONT COLOR=purple>[T</FONT><SUP><FONT COLOR=purple>+</FONT></SUP><FONT COLOR=purple>03]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Taivalsaari</SPAN>, Antero et&nbsp;al.
<EM>Connected Limited Device Configuration 1.1</EM>.<BR>
<A HREF="https://www.jcp.org/en/jsr/detail?id=139">https://www.jcp.org/</A>.
Mar. 2003<BR>
<BR>
<DT CLASS="dt-list"><A NAME="sm:jsr37"><FONT COLOR=purple>[Van00]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Van Peursem</SPAN>, Jim.
<EM>Mobile Information Device Profile (JSR-37)</EM>.<BR>
<A HREF="https://www.jcp.org/en/jsr/detail?id=37">https://www.jcp.org/</A>.
Sep. 2000<BR>
<BR>
<DT CLASS="dt-list"><A NAME="sm:jsr118"><FONT COLOR=purple>[VW02]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Van Peursem</SPAN>, Jim ; <SPAN STYLE="font-variant:small-caps">Warden</SPAN>, James.
<EM>Mobile Information Device Profile for Java -
 Version 2.0</EM>.<BR>
<A HREF="https://www.jcp.org/en/jsr/detail?id=118">https://www.jcp.org/</A>.
Nov. 2002<BR>
<BR>
<DT CLASS="dt-list"><A NAME="wp:bb"><FONT COLOR=purple>[Wik06a]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Wikipedia Community</SPAN>.
<EM>Basisband</EM>.<BR>
<A HREF="https://de.wikipedia.org/wiki/Basisband">https://de.wikipedia.org/</A>.
Mar. 2006<BR>
<BR>
<DT CLASS="dt-list"><A NAME="wp:bt"><FONT COLOR=purple>[Wik06b]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Wikipedia Community</SPAN>.
<EM>Bluetooth</EM>.<BR>
<A HREF="https://de.wikipedia.org/wiki/Bluetooth">https://de.wikipedia.org/</A>.
Mar. 2006<BR>
<BR>
<DT CLASS="dt-list"><A NAME="wp:ism"><FONT COLOR=purple>[Wik06c]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Wikipedia Community</SPAN>.
<EM>ISM-Band</EM>.<BR>
<A HREF="https://de.wikipedia.org/wiki/ISM">https://de.wikipedia.org/</A>.
Feb. 2006<BR>
<BR>
<DT CLASS="dt-list"><A NAME="wp:mpv"><FONT COLOR=purple>[Wik06d]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Wikipedia Community</SPAN>.
<EM>Multiplexverfahren</EM>.<BR>
<A HREF="https://de.wikipedia.org/wiki/Multiplexverfahren">https://de.wikipedia.org/</A>.
Feb. 2006<BR>
<BR>
<DT CLASS="dt-list"><A NAME="wp:mp"><FONT COLOR=purple>[Wik06e]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Wikipedia Community</SPAN>.
<EM>Multiplexverfahren</EM>.<BR>
<A HREF="https://de.wikipedia.org/wiki/Multiplexverfahren">https://de.wikipedia.org/</A>.
Mar. 2006<BR>
<BR>
<DT CLASS="dt-list"><A NAME="rx:bhci"><FONT COLOR=purple>[Xil05]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Xilinx</SPAN>.
<EM>Bluetooth HCI Bridging</EM>.<BR>
<A HREF="https://www.xilinx.com/esp/wireless/bluetooth/hci_bridging.htm">https://www.xilinx.com/</A>.
2005<BR>
<BR>
<DT CLASS="dt-list"><A NAME="wired:btsec"><FONT COLOR=purple>[Zet04]</FONT></A><DD CLASS="dd-list">
<SPAN STYLE="font-variant:small-caps">Zetter</SPAN>, Kim.
<EM>Security Cavities Ail Bluetooth</EM>.<BR>
<A HREF="https://www.wired.com/news/privacy/0,64463-1.html?tw=wn_story_page%
_next1">https://www.wired.com/</A>.
Aug. 2004</DL>



<!--TOC chapter Index-->

<H1 CLASS="chapter">Index</H1><!--SEC END -->


<TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD VALIGN=top ALIGN=left><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>BulkObjectPusher</TT>, <A HREF="#@default119">3.2.2</A>, <A HREF="#@default141">4.3</A>
<LI CLASS="li-itemize"><TT>Connector.open()</TT>, <A HREF="#@default92">2.5.8.1</A>
<LI CLASS="li-itemize"><TT>Constants</TT>, <A HREF="#@default112">3.2.1</A>
<LI CLASS="li-itemize"><TT>IObexObjectPassing</TT>, <A HREF="#@default111">3.2.1</A>, <A HREF="#@default143">4.3</A>
<LI CLASS="li-itemize"><TT>ObjectPusher</TT>, <A HREF="#@default118">3.2.2</A>
<LI CLASS="li-itemize"><TT>ObjectReceiver</TT>, <A HREF="#@default117">3.2.2</A>, <A HREF="#@default142">4.3</A>
<LI CLASS="li-itemize"><TT>ReceiverRequestHandler</TT>, <A HREF="#@default120">3.2.2</A>
<LI CLASS="li-itemize"><TT>retrieveDevices()</TT>, <A HREF="#@default84">2.5.6.1</A>
<LI CLASS="li-itemize"><TT>startInquiry()</TT>, <A HREF="#@default85">2.5.6.1</A>
<BR>
<BR>
<LI CLASS="li-itemize">ACL Control, <A HREF="#@default25">2.1.2.2</A>
<LI CLASS="li-itemize">Anforderungen, <A HREF="#@default76">2.5.1</A>
<LI CLASS="li-itemize">Anwendungsszenarien, <A HREF="#@default1">1.3</A>
<LI CLASS="li-itemize">API
<UL CLASS="itemize"><LI CLASS="li-itemize">
Bluetooth (JSR-82), <A HREF="#@default74">2.5</A>
</UL>
<LI CLASS="li-itemize">Auffindbarkeitszustand, <A HREF="#@default34">2.1.5</A>

<UL CLASS="itemize"><LI CLASS="li-itemize">
General discoverable mode, <A HREF="#@default40">2.1.5</A>
<LI CLASS="li-itemize">Limited discoverable mode, <A HREF="#@default39">2.1.5</A>
<LI CLASS="li-itemize">Non-discoverable mode, <A HREF="#@default38">2.1.5</A>
</UL>
<LI CLASS="li-itemize">Aufteilung des Projekts, <A HREF="#@default138">4.2</A>
<BR>
<BR>
<LI CLASS="li-itemize">Beispielapplikation, <A HREF="#@default140">4.3</A>
<LI CLASS="li-itemize">Beobachter-Muster, <A HREF="#@default116">3.2.2</A>
<LI CLASS="li-itemize">Bin�res HTTP, <A HREF="#@default99">2.5.8.2</A>
<LI CLASS="li-itemize">Bluetooth, <A HREF="#@default5">2.1</A>

<UL CLASS="itemize"><LI CLASS="li-itemize">
�bertragungsraten, <A HREF="#@default15">2.1</A>
<LI CLASS="li-itemize">Java (JSR-82), <A HREF="#@default108">3.1.2</A>
<LI CLASS="li-itemize">Klassifikation, <A HREF="#@default13">2.1</A>
<LI CLASS="li-itemize">Reichweite, <A HREF="#@default11">2.1</A>
<LI CLASS="li-itemize">Sendeleistung, <A HREF="#@default12">2.1</A>
<LI CLASS="li-itemize">Sicherheit, <A HREF="#@default31">2.1.4</A>
<LI CLASS="li-itemize">Stack, <A HREF="#@default106">3.1.1</A>
</UL>
<LI CLASS="li-itemize">Bluetooth Implementierungen, <A HREF="#@default41">2.1.6</A>
<BR>
<BR>
<LI CLASS="li-itemize">CLDC, <A HREF="#@default43">2.3</A>

<UL CLASS="itemize"><LI CLASS="li-itemize">
Sicherheit, <A HREF="#@default49">2.3.2</A>

<UL CLASS="itemize"><LI CLASS="li-itemize">
Application-level, <A HREF="#@default53">2.3.2</A>
<LI CLASS="li-itemize">End-to-End, <A HREF="#@default55">2.3.2</A>
<LI CLASS="li-itemize">Low-level, <A HREF="#@default51">2.3.2</A>
</UL>
</UL>
<LI CLASS="li-itemize">Client-/Server Modell, <A HREF="#@default81">2.5.5</A>
<LI CLASS="li-itemize">Connected Limited Device Configuration, see <I>CLDC</I>
<LI CLASS="li-itemize">Connection String, <A HREF="#@default95">2.5.8.1</A>
<BR>
<BR>
<LI CLASS="li-itemize">Daten�bertragungsraten, <A HREF="#@default14">2.1</A>
<LI CLASS="li-itemize">Datenbank, <A HREF="#@default59">2.4.1</A>
<LI CLASS="li-itemize">Datentransfer, <A HREF="#@default88">2.5.8</A>
<LI CLASS="li-itemize">Datentransport, <A HREF="#@default16">2.1</A>
<LI CLASS="li-itemize">Design
<UL CLASS="itemize"><LI CLASS="li-itemize">
Exceptions Paket, <A HREF="#@default123">3.2.4</A>
<LI CLASS="li-itemize">Impl Paket, <A HREF="#@default113">3.2.2</A>
<LI CLASS="li-itemize">OOP Paket, <A HREF="#@default109">3.2.1</A>
<LI CLASS="li-itemize">Util Paket, <A HREF="#@default121">3.2.3</A>
</UL>
<LI CLASS="li-itemize">Device Discovery, <A HREF="#@default83">2.5.6.1</A>
<LI CLASS="li-itemize">Discovery, <A HREF="#@default82">2.5.6</A>
<BR>
<BR>
<LI CLASS="li-itemize">Eigenschaften (JSR-82), <A HREF="#@default80">2.5.4</A>
<LI CLASS="li-itemize">Exceptions Paket, <A HREF="#@default124">3.2.4</A>
<BR>
<BR>
<LI CLASS="li-itemize">Funktionsweise OOP, <A HREF="#@default127">3.3</A>
<BR>
<BR>
<LI CLASS="li-itemize">GAP, <A HREF="#@default32">2.1.5</A>
<LI CLASS="li-itemize">GCF, <A HREF="#@default48">2.3.1</A>
<LI CLASS="li-itemize">Generic Access Profile, see <I>GAP</I>
<LI CLASS="li-itemize">GFSK, <A HREF="#@default7">2.1</A>
<LI CLASS="li-itemize">GIAC, <A HREF="#@default37">2.1.5</A>
<LI CLASS="li-itemize">Grundlagen
<UL CLASS="itemize"><LI CLASS="li-itemize">
Bluetooth, <A HREF="#@default6">2.1</A>
<LI CLASS="li-itemize">technische, <A HREF="#@default3">2</A>
</UL>
<BR>
<BR>
<LI CLASS="li-itemize">Hardware-Voraussetzungen
<UL CLASS="itemize"><LI CLASS="li-itemize">
CLDC, <A HREF="#@default47">2.3</A>
</UL>
<BR>
<BR>
<LI CLASS="li-itemize">Impl Paket, <A HREF="#@default114">3.2.2</A>
<LI CLASS="li-itemize">Implementierung, <A HREF="#@default126">3.3</A>
<LI CLASS="li-itemize">Inquiry
<UL CLASS="itemize"><LI CLASS="li-itemize">
Modi, <A HREF="#@default35">2.1.5</A>
</UL>
<BR>
<BR>
<LI CLASS="li-itemize">J2ME, <A HREF="#@default42">2.2</A>

<UL CLASS="itemize"><LI CLASS="li-itemize">
MIDlet, <A HREF="#@default132">4.1</A>
</UL>
<LI CLASS="li-itemize">JSR-82, <A HREF="#@default107">3.1.2</A>

<UL CLASS="itemize"><LI CLASS="li-itemize">
API, <A HREF="#@default73">2.5</A>
</UL>
<LI CLASS="li-itemize">JSR-82 Paketierung, <A HREF="#@default77">2.5.2</A>
<LI CLASS="li-itemize">JSR-82 Properties, <A HREF="#@default78">2.5.4</A>
<BR>
<BR>
<LI CLASS="li-itemize">Klassifikation, <A HREF="#@default10">2.1</A>
<LI CLASS="li-itemize">Kollisionsvermeidung, <A HREF="#@default19">2.1.1.1</A>
<LI CLASS="li-itemize">Kommunikation, <A HREF="#@default87">2.5.8</A>
<BR>
<BR>
</UL></TD>
<TD VALIGN=top ALIGN=left><UL CLASS="itemize"><LI CLASS="li-itemize">L2CAP Layer, <A HREF="#@default29">2.1.3</A>
<LI CLASS="li-itemize">LIAC, <A HREF="#@default36">2.1.5</A>
<LI CLASS="li-itemize">Link Control, <A HREF="#@default24">2.1.2.2</A>
<LI CLASS="li-itemize">Logical Layer, <A HREF="#@default21">2.1.2</A>
<LI CLASS="li-itemize">Logical Links, <A HREF="#@default23">2.1.2.2</A>
<LI CLASS="li-itemize">Logical Transports, <A HREF="#@default22">2.1.2.1</A>
<BR>
<BR>
<LI CLASS="li-itemize">MIDlet
<UL CLASS="itemize"><LI CLASS="li-itemize">
&#8222;Hello World&#8220;, <A HREF="#@default136">4.1.1</A>
<LI CLASS="li-itemize">Lebenszyklus, <A HREF="#@default133">4.1.1</A>
<LI CLASS="li-itemize">Zustandsautomat, <A HREF="#@default134">4.1.1</A>
</UL>
<LI CLASS="li-itemize">MIDP, <A HREF="#@default57">2.4</A>

<UL CLASS="itemize"><LI CLASS="li-itemize">
Record Store, <A HREF="#@default65">2.4.1.1</A>
<LI CLASS="li-itemize">Records, <A HREF="#@default68">2.4.1.2</A>
<LI CLASS="li-itemize">RMS, <A HREF="#@default61">2.4.1</A>
<LI CLASS="li-itemize">Sicherheit, <A HREF="#@default71">2.4.2</A>
<LI CLASS="li-itemize">Zugriffsrechte, <A HREF="#@default72">2.4.2</A>
</UL>
<LI CLASS="li-itemize">Mobile Information Device Profile, see <I>MIDP</I>
<BR>
<BR>
<LI CLASS="li-itemize">Netbeans IDE
<UL CLASS="itemize"><LI CLASS="li-itemize">
Macintosh, <A HREF="#@default105">3.1</A>
</UL>
<BR>
<BR>
<LI CLASS="li-itemize">OBEX, <A HREF="#@default97">2.5.8.2</A>

<UL CLASS="itemize"><LI CLASS="li-itemize">
Operationen, <A HREF="#@default101">2.5.8.2</A>
<LI CLASS="li-itemize">verbindungslos, <A HREF="#@default100">2.5.8.2</A>
</UL>
<LI CLASS="li-itemize">OBEX Object Passing, <A HREF="#@default103">3</A>
<LI CLASS="li-itemize">OBject Exchange, see <I>OBEX</I>
<LI CLASS="li-itemize">Observer-Pattern, <A HREF="#@default115">3.2.2</A>
<LI CLASS="li-itemize">OOP, <A HREF="#@default102">3</A>

<UL CLASS="itemize"><LI CLASS="li-itemize">
Beispielapplikation, <A HREF="#@default139">4.3</A>
<LI CLASS="li-itemize">Beispielapplikation importieren, <A HREF="#@default146">A.2</A>
<LI CLASS="li-itemize">Entwicklung, <A HREF="#@default131">4</A>
<LI CLASS="li-itemize">Funktionsweise, <A HREF="#@default125">3.3</A>
<LI CLASS="li-itemize">Paket, <A HREF="#@default110">3.2.1</A>
<LI CLASS="li-itemize">Projekt erzeugen, <A HREF="#@default144">A.1</A>
<LI CLASS="li-itemize">Tests, <A HREF="#@default129">3.4</A>
</UL>
<BR>
<BR>
<LI CLASS="li-itemize">Persistenz, <A HREF="#@default60">2.4.1</A>
<LI CLASS="li-itemize">Physical Channel, <A HREF="#@default18">2.1.1.1</A>
<LI CLASS="li-itemize">Physical Layer, <A HREF="#@default17">2.1.1</A>
<LI CLASS="li-itemize">Physical Links, <A HREF="#@default20">2.1.1.2</A>
<LI CLASS="li-itemize">Projekt erzeugen, <A HREF="#@default145">A.1</A>
<LI CLASS="li-itemize">Projektorganisation, <A HREF="#@default137">4.2</A>
<LI CLASS="li-itemize">Properties (JSR-82), <A HREF="#@default79">2.5.4</A>
<BR>
<BR>
<LI CLASS="li-itemize">Randbedingungen, <A HREF="#@default2">1.4</A>
<LI CLASS="li-itemize">Record Management System, see <I>RMS</I>
<LI CLASS="li-itemize">Record Store, <A HREF="#@default64">2.4.1.1</A>
<LI CLASS="li-itemize">Records, <A HREF="#@default67">2.4.1.2</A>
<LI CLASS="li-itemize">Reichweite, <A HREF="#@default8">2.1</A>
<LI CLASS="li-itemize">Requirements
<UL CLASS="itemize"><LI CLASS="li-itemize">
JSR-82, <A HREF="#@default75">2.5.1</A>
</UL>
<LI CLASS="li-itemize">Ressourcen
<UL CLASS="itemize"><LI CLASS="li-itemize">
CLDC, <A HREF="#@default46">2.3</A>
</UL>
<LI CLASS="li-itemize">RFCOMM, <A HREF="#@default90">2.5.8.1</A>

<UL CLASS="itemize"><LI CLASS="li-itemize">
Connection String, <A HREF="#@default96">2.5.8.1</A>
<LI CLASS="li-itemize">Verbindungskennzeichner, <A HREF="#@default94">2.5.8.1</A>
</UL>
<LI CLASS="li-itemize">RMS, <A HREF="#@default62">2.4.1</A>

<UL CLASS="itemize"><LI CLASS="li-itemize">
Record Store, <A HREF="#@default66">2.4.1.1</A>
<LI CLASS="li-itemize">Records, <A HREF="#@default69">2.4.1.2</A>
</UL>
<BR>
<BR>
<LI CLASS="li-itemize">Sendeleistung, <A HREF="#@default9">2.1</A>
<LI CLASS="li-itemize">Sequenzdiagramm OOP, <A HREF="#@default128">3.3</A>
<LI CLASS="li-itemize">Serial Port Profile, <A HREF="#@default91">2.5.8.1</A>
<LI CLASS="li-itemize">Service Discovery, <A HREF="#@default86">2.5.6.2</A>
<LI CLASS="li-itemize">Sicherheit
<UL CLASS="itemize"><LI CLASS="li-itemize">
Bluetooth, <A HREF="#@default30">2.1.4</A>
<LI CLASS="li-itemize">CLDC, <A HREF="#@default50">2.3.2</A>

<UL CLASS="itemize"><LI CLASS="li-itemize">
Application-level, <A HREF="#@default54">2.3.2</A>
<LI CLASS="li-itemize">End-to-End, <A HREF="#@default56">2.3.2</A>
<LI CLASS="li-itemize">Low-level, <A HREF="#@default52">2.3.2</A>
</UL>
<LI CLASS="li-itemize">MIDP, <A HREF="#@default70">2.4.2</A>
</UL>
<LI CLASS="li-itemize">SPP, <A HREF="#@default89">2.5.8.1</A>
<BR>
<BR>
<LI CLASS="li-itemize">Technische Grundlagen, <A HREF="#@default4">2</A>

<UL CLASS="itemize"><LI CLASS="li-itemize">
CLDC, <A HREF="#@default45">2.3</A>
</UL>
<LI CLASS="li-itemize">Technische Voraussetzungen, <A HREF="#@default104">3.1</A>
<LI CLASS="li-itemize">Test, <A HREF="#@default130">3.4</A>
<BR>
<BR>
<LI CLASS="li-itemize">User Asynchronous/Isochronous, <A HREF="#@default26">2.1.2.2</A>
<LI CLASS="li-itemize">User Extended Synchronous, <A HREF="#@default28">2.1.2.2</A>
<LI CLASS="li-itemize">User Synchronous, <A HREF="#@default27">2.1.2.2</A>
<LI CLASS="li-itemize">Util Paket, <A HREF="#@default122">3.2.3</A>
<BR>
<BR>
<LI CLASS="li-itemize">Verbindungskennzeichner, <A HREF="#@default93">2.5.8.1</A>
<BR>
<BR>
<LI CLASS="li-itemize">Zielsetzung, <A HREF="#@default0">1.2</A>
<LI CLASS="li-itemize">Zustandsautomat MIDlet, <A HREF="#@default135">4.1.1</A>
</UL></TD>
</TR></TABLE>
<!--HTMLFOOT-->
<DIV CLASS="flushright"><A HREF="https://oop.coffeecrew.org"><FONT SIZE=2>OBEX Object Passing Home</FONT></A><FONT SIZE=2> </FONT><A HREF="../dox/ObexObjectPassing.pdf"><FONT SIZE=2>(PDF)</FONT></A><FONT SIZE=2> </FONT><A HREF="https://www.coffeecrew.org"><FONT SIZE=2><IMG SRC="ccgoff.png" alt="CCGLogo" width="16" height="16"></FONT></A></DIV><!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="https://hevea.inria.fr/index.html"><EM>H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
